[
  {
    "id": 100,
    "date": "2019/12/12",
    "title": "Create a Custom VM Image",
    "itemList": [
      {
        "text": "<p>To create an image of a virtual machine, you need to prepare the VM by deprovisioning, deallocating, and then marking the source VM as generalized. Once the VM has been prepared, you can create an image.</p>",
        "image": ""
      },
      {
        "text": "<p>First ssh to the VM:<br><code>ssh user@ip</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then deprovision VM:<br><code>sudo waagent -deprovision+user -force</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then close the SSH session:<br><code>exit</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then deallocate the VM using az vm deallocate:<br><code>az vm deallocate --resource-group myResourceGroup --name myVM</code></p>",
        "image": ""
      },
      {
        "text": "<p>set the state of the VM as generalized with az vm generalize so the Azure platform knows the VM has been generalized. You can only create an image from a generalized VM:<br><code>az vm generalize --resource-group myResourceGroup --name myVM</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then you can create an image of the VM by using az image create. The following example creates an image named myImage from a VM named myVM:<br><code>az image create --resource-group myResourceGroup --name myImage --source myVM</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then you can create one or more new VMs from the image using az vm create. The following example creates a VM named myVMfromImage from the image named myImage:<br><code>az vm create --resource-group myResourceGroup --name myVMfromImage --image myImage --admin-username azureuser --generate-ssh-keys</code></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 200,
    "date": "2019/12/12",
    "title": "Install the Elastic Stack on an Azure VM",
    "itemList": [
      {
        "text": "<p>First, create a RG:<br><code>az group create --name myResourceGroup --location eastus</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then create a VM:<br><code>az vm create --resource-group myResourceGroup --name myVM --image UbuntuLTS --admin-username azureuser --generate-ssh-keys</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then find public IP address of your VM:<br><code>az network public-ip list --resource-group myResourceGroup --query [].ipAddress</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then create an SSH session with the virtual machine:<br><code>ssh azureuser@ip</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then import the Elasticsearch signing key and update your APT sources list to include the Elastic package repository:<br><code>wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -<br>echo 'deb https://artifacts.elastic.co/packages/5.x/apt stable main' | sudo tee -a /etc/apt/sources.list.d/elastic-5.x.list</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then install Java VM:<br><code>sudo apt update && sudo apt install openjdk-8-jre-headless</code><br><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</code></p>",
        "image": ""
      },
      {
        "text": "<p>update Ubuntu package sources and install Elasticsearch, Kibana, and Logstash:<br><code>sudo apt update && sudo apt install elasticsearch kibana logstash</code></p>",
        "image": ""
      },
      {
        "text": "<p>Start Elasticsearch on your VM:<br><code>sudo systemctl start elasticsearch.service</code></p>",
        "image": ""
      },
      {
        "text": "<p>Verify that Elasticsearch is running on the VM:<br><code>sudo curl -XGET 'localhost:9200/'</code></p>",
        "image": ""
      },
      {
        "text": "<p>Start Logstash and add data to Elasticsearch:<br><code>sudo systemctl start logstash.service</code><br><code>sudo /usr/share/logstash/bin/logstash -e 'input { stdin { } } output { stdout {} }'</code></p>",
        "image": ""
      },
      {
        "text": "<p>Set up Logstash to forward the kernel messages from this VM to Elasticsearch. Create a new file in an empty directory called vm-syslog-logstash.conf and paste in the following Logstash configuration:</code></p>",
        "image": "../assets/image/itCloud/azure/logstash.png"
      },
      {
        "text": "<p>Test this configuration and send the syslog data to Elasticsearch:<br><code>sudo /usr/share/logstash/bin/logstash -f vm-syslog-logstash.conf</code></p>",
        "image": ""
      },
      {
        "text": "<p>Edit /etc/kibana/kibana.yml and change the IP address Kibana listens on so you can access it from your web browser:<br><code>server.host:'0.0.0.0'</code></p>",
        "image": ""
      },
      {
        "text": "<p>Start Kibana:<br><code>sudo systemctl start kibana.service</code></p>",
        "image": ""
      },
      {
        "text": "<p>Open port 5601 from the Azure CLI to allow remote access to the Kibana console:<br><code>az vm open-port --port 5601 --resource-group myResourceGroup --name myVM</code></p>",
        "image": ""
      },
      {
        "text": "<p>Open up the Kibana console (internet access):<br><code>http://vm_ip:5601/app/kibana#/discover?_g=()</code></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 300,
    "date": "2019/12/14",
    "title": "Secure Nginx on a Linux VM in Azure with SSL cert",
    "itemList": [
      {
        "text": "<p>First, create a RG:<br><code>az group create --name myResourceGroupSecureWeb --location eastus</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then create a Key Vault with az keyvault create and enable it for use when you deploy a VM:<br><code>keyvault_name=mykeyvaultname99</code></p>",
        "image": ""
      },
      {
        "text": "<p>Then create a Key Vault with az keyvault create and enable it for use when you deploy a VM:<br><code>az keyvault create --resource-group myResourceGroupSecureWeb --name $keyvault_name --enabled-for-deployment</code></p>",
        "image": ""
      },
      {
        "text": "<p>For production use, you should import a valid certificate signed by trusted provider with az keyvault certificate import. For this tutorial, the following example shows how you can generate a self-signed certificate with az keyvault certificate create that uses the default certificate policy:<br><code>az keyvault certificate create --vault-name $keyvault_name --name mycert --policy '$(az keyvault certificate get-default-policy)'</code></p>",
        "image": ""
      },
      {
        "text": "<p>To use the certificate during the VM create process, obtain the ID of your certificate with az keyvault secret list-versions:<br><code>secret=$(az keyvault secret list-versions --vault-name $keyvault_name --name mycert --query '[?attributes.enabled].id' --output tsv)</code></p>",
        "image": ""
      },
      {
        "text": "<p>Convert the certificate with az vm secret format:<br><code>vm_secret=$(az vm secret format --secrets '$secret' -g myResourceGroupSecureWeb --keyvault $keyvault_name)</code></p>",
        "image": ""
      },
      {
        "text": "<p><p>Cloud-init is a widely used approach to customize a Linux VM as it boots for the first time. You can use cloud-init to install packages and write files, or to configure users and security. As cloud-init runs during the initial boot process, there are no additional steps or required agents to apply your configuration.</p><p>When you create a VM, certificates and keys are stored in the protected /var/lib/waagent/ directory. To automate adding the certificate to the VM and configuring the web server, use cloud-init. In this example, you install and configure the NGINX web server. You can use the same process to install and configure Apache.</p><p>Create a file named cloud-init-web-server.txt and paste the following configuration:</p></p>",
        "image": "../assets/image/itCloud/azure/azureCloudInit.png"
      },
      {
        "text": "<p>Now create a VM with az vm create. The certificate data is injected from Key Vault with the --secrets parameter. You pass in the cloud-init config with the --custom-data parameter:<br><code>az vm create --resource-group myResourceGroupSecureWeb --name myVM --image UbuntuLTS --admin-username azureuser --generate-ssh-keys --custom-data cloud-init-web-server.txt --secrets '$vm_secret'</code></p>",
        "image": ""
      },
      {
        "text": "<p>To allow secure web traffic to reach your VM, open port 443 from the Internet with az vm open-port:<br><code>az vm open-port --resource-group myResourceGroupSecureWeb --name myVM --port 443</code></p>",
        "image": ""
      },
      {
        "text": "<p>To access the site:<br><code>https://ip</code></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 400,
    "date": "2019/12/15",
    "title": "Find and delete unattached NICs",
    "itemList": [
      {
        "text": "<p>The virtualMachine property for a NIC stores the ID and resource group of the VM the NIC is attached to. The following script loops through all the NICs in a subscription and checks if the virtualMachine property is null. If this property is null, the NIC is not attached to a VM.</p>",
        "image": ""
      },
      {
        "text": "<p>To view all the unattached NICs, it's highly recommend to first run the script with the deleteUnattachedNics variable to 0. To delete all the unattached NICs after you review the list output, run the script with deleteUnattachedNics to 1.</p>",
        "image": ""
      },
      {
        "text": "<p>Then run the following az cli commands in Azure Cloud Shell:</p>",
        "image": "../assets/image/itCloud/azure/autoDeleteNics.png"
      }
    ]
  },
  {
    "id": 500,
    "date": "2020/01/18",
    "title": "Azure AD vs. On-Premises AD",
    "itemList": [
      {
        "text": "<p>The Active Directory capabilities that are part of Windows Server actually include several different roles, such as Active Directory Certificate Services (AD CS), Active Directory Lightweight Directory Services (AD LDS), Active Directory Federation Services (AD FS), and Active Directory Rights Management Services (AD RMS). However, most people think of Active Directory as the Active Directory Domain Services role, and this 'Active Directory' is what most people mean when comparing AD with Azure Active Directory.</p>",
        "image": ""
      },
      {
        "text": "<p>The reality is that Active Directory Domain Services (henceforth just Active Directory) in Windows Server is completely different from Azure Active Directory (Azure AD), and they actually have different focus areas. When you think about Active Directory you're talking about a true directory service that has a hierarchical structure (based on X.500) that uses DNS as its locator mechanism and can be interacted with via LDAP. In addition, Active Directory primarily uses Kerberos for authentication. Active Directory enables organizational units (OUs) and Group Policy Objects (GPOs) in addition to actually joining machines to the domain, and trusts are created between domains.</p>",
        "image": ""
      },
      {
        "text": "<p>Azure AD, while having some aspects of a directory service, is really an identity solution and allows users and groups to be created but in a flat structure without OUs or GPOs. You can't join a machine to Azure AD. There's no Kerberos authentication, and you can't query it via LDAP. This is OK because the things Azure AD doesn't have make sense on-premises, where all types of communication are possible. However, Azure AD is focused around identity throughout the Internet, where the types of communication are typically limited to HTTP (port 80) and HTTPS (port 443) and are used by all types of devices—not just corporate assets. Authentication is performed through a number of protocols such as SAML, WS-Federation, and OAuth. It's possible to query Azure AD but instead of using LDAP you use a REST API called AD Graph API. These all work over HTTP and HTTPS.</p>",
        "image": ""
      },
      {
        "text": "<p>When you think about using Azure AD, you'll use it for authentication for Internet-based services such as Office 365 and Azure, as well as much more, including Facebook and thousands of other services that are already federated with Azure AD (which mean they trust Azure AD without you having to do anything other than enable that application or service to be used by your users).</p>",
        "image": ""
      },
      {
        "text": "<p>For the best seamless experience, you think about combining your on-premises Active Directory with Azure AD by setting up directory synchronization (including password sync) and federation. This allows users on their corporate assets to log on with their AD account and when they access Internet services, such as Office 365, authentication with Azure AD just happens seamlessly via the federation, allowing access to all the different services that Azure AD is federated with. This is actually a great benefit of federating your on-premises AD with Azure AD. It's possible for your organization to federate with all the different companies out on the Internet, but this is a lot of work to set up and maintain. However, if you just federate with Azure AD then you're now federated by proxy with all the organizations that Azure AD is federated with—which is pretty much all of the major services on the Internet today. Think of Azure AD as acting like a federation hub.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 600,
    "date": "2020/01/20",
    "title": "Microsoft ID platform Endpoints",
    "itemList": [
      {
        "text": "<p><b>Fetch the OpenID Connect metadata document</b> - https://login.microsoftonline.com/{tenant}/v2.0/.well-known/openid-configuration</p>",
        "image": "../assets/image/itCloud/azure/openIDConnectEndPoint.png"
      },
      {
        "text": "<p>Typically, you would use this metadata document to configure an OpenID Connect library or SDK; the library would use the metadata to do its work. However, if you're not using a pre-built OpenID Connect library, you can follow the steps in the remainder of this article to do sign-in in a web app by using the Microsoft identity platform endpoint.</p>",
        "image": "../assets/image/itCloud/azure/openIDConnectEndPoint.png"
      }
    ]
  },
  {
    "id": 700,
    "date": "2020/01/30",
    "title": "Best Practices for network security",
    "itemList": [
      {
        "text": "<p><ul><li><b>Use strong network controls</b><br>As you plan your network and the security of your network, we recommend that you centralize:<ul><li>Management of core network functions like ExpressRoute, virtual network and subnet provisioning, and IP addressing.</li><li>Governance of network security elements, such as network virtual appliance functions like ExpressRoute, virtual network and subnet provisioning, and IP addressing.</li></ul><li>Logically segment subnets</li><li>Adopt a Zero Trust approach</li><li>Control routing behavior</li><li>Use virtual network appliances</li><li>Deploy perimeter networks (DMZ) for security zones</li><li>Avoid exposure to the internet with dedicated WAN links</li><li>Disable RDP/SSH Access to virtual machines</li><li>Secure your critical Azure service resources to only your virtual networks</li><ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1000,
    "date": "2019/12/10",
    "title": "Azure CLI",
    "itemList": [
      {
        "text": "<p><code>az account show</code> - show your account info</p>",
        "image": ""
      },
      {
        "text": "<p><code>az acr build -t 'captureorder:{{.Run.ID}}' -r <unique-acr-name></code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az acr create --resource-group <resource-group> --name <unique-acr-name> --sku Standard --location eastus</code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az aks update -n <aks-cluster-name> -g <resource-group> --attach-acr <your-acr-name></code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az ad sp create-for-rbac --role='Monitoring Reader' --scopes='/subscriptions/cad64ad8-6bce-44ea-bd9f-b45beb03458a/resourceGroups/PromitorRG'</code> - Create a Service Principal</p>",
        "image": ""
      },           
      {
        "text": "<p><code>az aks get-credentials --name PromitorCluster --resource-group PromitorRG</code> - Get your cluster’s credentials. This will save these credentials to your kubeconfig file and set your new cluster as your current context for all kubectl commands.</p>",
        "image": ""
      },
      {
        "text": "<p><code>az aks enable-addons --resource-group k8s --name k8sCluster --addons monitoring --workspace-resource-id /subscriptions/cad64ad8-6bce-44ea-bd9f-b45beb03458a/resourcegroups/k8s/providers/microsoft.operationalinsights/workspaces/k8sworkspace99</code> - enable the monitoring add-on</p>",
        "image": ""
      },
      {
        "text": "<p><code>az aks scale --resource-group <resource-group> --name <unique-aks-cluster-name> --node-count 4</code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az container create -g <resource-group> -n loadtest --image azch/loadtest --restart-policy Never -e SERVICE_ENDPOINT=https://<hostname order capture service></code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az container logs -g <resource-group> -n loadtest</code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az container delete -g <resource-group> -n loadtest</code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az group create --name myResourceGroup --location eastus</code> - create a group</p>",
        "image": ""
      },
      {
        "text": "<p><code>az group list</code> - list groups</p>",
        "image": ""
      },
      {
        "text": "<p><code>az login</code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az network public-ip list --resource-group myResourceGroup --query [].ipAddress</code> - find public IP address</p>",
        "image": ""
      },
      {
        "text": "<p><code>az resource create --resource-type Microsoft.OperationalInsights/workspaces --name k8sWorkspace99 --resource-group k8s --location eastus --properties '{}' -o table</code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az resource show --resource-type Microsoft.OperationalInsights/workspaces --resource-group k8s --name k8sWorkspace99 --query 'id' -o tsv</code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az servicebus namespace create --resource-group PromitorRG --name service-bus-ns99 --location eastus</code> - Create a servicebus namespace</p>",
        "image": ""
      },
      {
        "text": "<p><code>az servicebus namespace authorization-rule keys list --resource-group PromitorRG --namespace-name service-bus-ns99 --name RootManageSharedAccessKey --query primaryConnectionString --output tsv</code> - Get the connection string for this Service Bus namespace</p>",
        "image": ""
      },
      {
        "text": "<p><code>az servicebus queue create --resource-group PromitorRG --namespace-name service-bus-ns99 --name demo_queue</code> - Create a servicebus queue</p>",
        "image": ""
      },
      {
        "text": "<p><code>az vm create --resource-group myResourceGroup --name myVM --image UbuntuLTS --admin-username azureuser --generate-ssh-keys</code> - create a VM</p>",
        "image": ""
      },
      {
        "text": "<p><code>az vm open-port --port 5601 --resource-group myResourceGroup --name myVM</code> - Open port 5601 from the Azure CLI to allow remote access</p>",
        "image": ""
      },
      {
        "text": "<p><code>echo version=$(az aks get-versions -l eastus --query 'orchestrators[-1].orchestratorVersion' -o tsv)</code> - Obtain AKS version</p>",
        "image": ""
      },
      {
        "text": "<p><code>echo sub=$(az account show --query 'id' -o tsv)</code> - Obtain your Azure subscription ID</p>",
        "image": ""
      },
      {
        "text": "<p><code>helm install orders-mongo stable/mongodb --set mongodbUsername=orders-user,mongodbPassword=orders-password,mongodbDatabase=akschallenge</code> - deploy MongoDB</p>",
        "image": ""
      },
      {
        "text": "<p><code>helm repo add stable https://kubernetes-charts.storage.googleapis.com/</code> - Add the stable Helm charts repository</p>",
        "image": ""
      },
      {
        "text": "<p><code>helm repo update</code> - Upate the repositories</p>",
        "image": ""
      },
      {
        "text": "<p><code>sensible-editor cloud-init-jenkins.txt</code> - enter sensible-editor fileName to create the file and see a list of available editors:<br></p>",
        "image": ""
      },
      {
        "text": "<p><code>ssh azureuser@40.87.62.106</p>",
        "image": ""
      }
    ]
  }
]