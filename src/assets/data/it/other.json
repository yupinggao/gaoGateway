[
  {
    "id": 5,
    "date": "2019/01/15",
    "title": "NodeJS",
    "itemList": [
      {
        "text": "<p>Node.js is an open source javascript server environment. Node.js runs single-threaded, non-blocking, asynchronously programming, which is very memory efficient.</p>",
        "image": ""
      },
      {
        "text": "<p>Node.js can do the following: <ul><li>Generate dynamic page content</li><li>Create, open, read, write, delete, and close files on the server</li><li>Collect form data</li><li>Add, delete, modify data in your database</li><li>Create REST APIs</li><li>Consume REST APIs</li></ul></p>",
        "image": ""
      },
      {
        "text": "<b>URL Module:</b><br/><p><code>var url = require('url');</code><br/><code>var adr = 'http://localhost:8080/default.htm?year=2017&month=february';</code><br/><code>var q = url.parse(adr, true);</code><br/><code>console.log(q.host); //returns 'localhost:8080'</code><br/><code>console.log(q.pathname); //returns '/default.htm'</code><br/><code>console.log(q.search); //returns '?year=2017&month=february'</code><br/><code>var qdata = q.query; //returns an object: { year: 2017, month: 'february' }</code><br/><code>console.log(qdata.month); //returns 'february'</code></p>",
        "image": ""
      },
      {
        "text": "<b>Somethings to remember:</b><br/><p><ul><li>node.js uses unlink to delete a file <code>fs.unlink(filename, function (err) {... ...})</code></li><li>node.js uses formidable mudule for uploading files: <code>var formidable = require('formidable');</code></li><li>node.js uses nodemailer to handle emails: <code>var nodemailer = require('nodemailer');</code></li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 30,
    "date": "2019/01/16",
    "title": "JavaScript 6/ECMAScript 6",
    "itemList": [
      {
        "text": "<p>JavaScript 6 or ECMAScript 6 (ECMA stands for European Computer Manufacturers Association) has some new features:<ul><li><code>let</code> statement allows you to declare a variable with block scope.</li><li><code>const</code> statement allows you to declare a constant.</li><li><code>exponentiation</code> operator (**) raises the first operand to the power of the second operand.</li><li>ES6 allows function parameters to have default values.</li><li><code>find()</code> method returns the value of the first array element that passes a test function.<br/><code>var numbers = [4, 9, 16, 25, 29];</code><br/><code>var first = numbers.find(myFunction);</code><br/><code>function myFunction(value, index, array) {</code><br/><code>&nbsp;&nbsp;&nbsp;return value > 18;</code><br/><code>}</code><br/></li><li><code>findIndex()</code> method returns the index of the first array element that passes a test function.</li><li>Arrow Functions (Lambda expression like function)</li></lu></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 40,
    "date": "2019/01/24",
    "title": "CSS",
    "itemList": [
      {
        "text": "<p>The !important directive affects the way in which your CSS cascades while following the rules you feel are most crucial and should be applied. A rule that has the !important directive is always applied no matter where that rule appears in the CSS document.</p><p>To make the paragraph text always red, from the above example, you will use:<br/><code>p { color: red !important; }<br/>p { color: black; }</code></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 50,
    "date": "2019/10/23",
    "title": "SASS",
    "itemList": [
      {
        "text": "<p>SASS (Syntactically Awesome Stylesheets) is a CSS pre-processor that lets you use variables, mathematical operations, mixins, loops, functions, imports, and other interesting functionalities that make writing CSS much more powerful. In some ways, you may think of SASS as a style sheet extension language because it extends the standard CSS characteristics by introducing the benefits of a basic programming language. So SASS will compile your code and generate the CSS output a browser can understand.</p>",
        "image": ""
      },
      {
        "text": "<p><b>It's CSS syntax friendly</b></p>",
        "image": ""
      },
      {
        "text": "<p><b>It offers variables for whatever you want</b></p>",
        "image": ""
      },
      {
        "text": "<p><b>It uses nested syntax</b></p>",
        "image": ""
      },
      {
        "text": "<p><b>It includes mixins</b></p>",
        "image": ""
      },
      {
        "text": "<p><b>You can divide and conquer</b></p>",
        "image": ""
      },
      {
        "text": "<p><b>It has a large community and is well documented</b></p>",
        "image": ""
      },
      {
        "text": "<p><b>If you know SASS, you can customize Bootstrap 4</b></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 60,
    "date": "2019/01/26",
    "title": "Angular",
    "itemList": [
      {
        "text": "<b>Angular Component Lifecycle Hooks</b><p>Angular creates a component, renders it, creates and renders its children, checks it when its data-bound properties change, and destroys it before removing it from the DOM. Angular offers lifecycle hooks that provide visibility into these key life moments and the ability to act when they occur. A directive has the same set of lifecycle hooks.</p><p>Directive and component instances have a lifecycle as Angular creates, updates, and destroys them. Developers can tap into key moments in that lifecycle by implementing one or more of the lifecycle hook interfaces in the Angular core library. Each interface has a single hook method whose name is the interface name prefixed with ng. For example, the OnInit interface has a hook method named ngOnInit() that Angular calls shortly after creating the component. The following table lists the Lifecycle Method:</p>",
        "image": "../assets/image/it/other/angularLifeCycle.png"
      },
      {
        "text": "<b>Angular Directives</b><p>There are three kinds of directives in Angular:<ol><li>Components—directives with a template</li><li>Structural directives—change the DOM layout by adding and removing DOM elements. Two examples are NgFor and NgIf.</li><li>Attribute directives—change the appearance or behavior of an element, component, or another directive. The built-in NgStyle directive in the Template Syntax guide, for example, can change several element styles at the same time.</li></ol></p>",
        "image": ""
      },
      {
        "text": "<b>Angular Decorators</b><p>There are four types of decorators in Angular:<ol><li>Class decorators, e.g. @Component and @NgModule</li><li>Property decorators for properties inside classes, e.g. @Input and @Output</li><li>Method decorators for methods inside classes, e.g. @HostListener</li><li>Parameter decorators for parameters inside class constructors, e.g. @Inject</li></ol></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 70,
    "date": "2019/01/26",
    "title": "New Features in Angular 6",
    "itemList": [
      {
        "text": "<p>Angular has come out with some amazing new features in version 6.0.0, especially in Angular-cli. Now, with Angular 6, you can easily update your old packages, create native web elements using Angular Elements, and many other things.</p>",
        "image": ""
      },
      {
        "text": "<b>ng add</b><p>ng add is a new command in Angular-cli that helps you install and download new packages in your angular apps. It works the same as npm, but it doesn’t replace it.<div class='jumbotron'>ng add @angular/elements</div></p>",
        "image": ""
      },
      {
        "text": "<b>ng update</b><p>ng update is a new Angular-cli command too. It’s used to update and upgrade your packages. It’s really helpful, for example, when you want to upgrade from Angular 5 to Angular 6, or any other package in your Angular app. <div class='jumbotron'>ng update @angular/core</div></p>",
        "image": ""
      },
      {
        "text": "<b>Declaring the providers inside the service itself</b><p>Before this update, you had to the declare the providers array in app.module.ts</p><p>Now with Angular 6, you can provide your service inside the supervisor itself by putting the providedIn:root property within the '@injectable' decorator. <div class='jumbotron'>import { Injectable } from '@angular/core'<br/><br/>@Injectable({<br/>&nbsp;&nbsp;&nbsp;&nbsp;providedIn: 'root'<br/>})</div></p>",
        "image": ""
      },
      {
        "text": "<b>Use ng-template instead of template directive</b><p>You can use ng-template to render the HTML instead of the template tag in the new version of Angular. ng-template is an Angular element, and it works when it is used with a structural directive such as *ngFor and *ngIf.</p>",
        "image": ""
      },
      {
        "text": "<b>Angular elements</b><p>Angular 6 introduced us to Angular elements. You’re able to render your Angular elements as native web elements, and they’re interpreted as trusted HTML elements.</p>",
        "image": ""
      },
      {
        "text": "<b>Upgrading to RxJS 6.0.0</b><p>Angular 6 uses the latest version of Rxjs library. Now you can enjoy the newest features of RxJS 6 in your Angular app.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 80,
    "date": "2019/01/26",
    "title": "JQuery",
    "itemList": [
      {
        "text": "<p>jQuery is a JavaScript Library. The jQuery library contains the following features:</p><ul><li>HTML/DOM manipulation</li><li>CSS manipulation</li><li>HTML event methods</li><li>Effects and animations</li><li>AJAX</li><li>Utilities</li></ul>",
        "image": ""
      },
      {
        "text": "<b>jQuery Syntax</b><p>The jQuery syntax is tailor-made for selecting HTML elements and performing some action on the element(s). Basic syntax is: <code>$(selector).action()</code><ol><li>A $ sign to define/access jQuery</li><li>A (selector) to 'query (or find)' HTML elements</li><li>A jQuery action() to be performed on the element(s)</li></ol></p>",
        "image": ""
      },
      {
        "text": "<b>Examples:</b><ol><li><code>$(this).hide()</code> - hides the current element.</li><li><code>$('p').hide()</code> - hides all 'p' elements</li><li><code>$('.test').hide()</code> - hides all elements with class='test'.</li><li><code>$('#test').hide()</code> - hides the element with id='test'.</li></ol></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 90,
    "date": "2019/01/30",
    "title": "Progress Web Apps (PWA)",
    "itemList": [
      {
        "text": "<b>Service Workers</b><p>A service worker is a script that your browser runs in the background, separate from a web page, opening the door to features that don't need a web page or user interaction. Today, they already include features like push notifications and background sync. In the future, service workers might support other things like periodic sync or geofencing. The core feature discussed in this tutorial is the ability to intercept and handle network requests, including programmatically managing a cache of responses.</p><p>The reason this is such an exciting API is that it allows you to support offline experiences, giving developers complete control over the experience.</p>",
        "image": ""
      },
      {
        "text": "<b>Things to note about a service worker:</b><p><ul><li>It's a JavaScript Worker, so it can't access the DOM directly. Instead, a service worker can communicate with the pages it controls by responding to messages sent via the postMessage interface, and those pages can manipulate the DOM if needed.</li><li>Service worker is a programmable network proxy, allowing you to control how network requests from your page are handled.</li><li>It's terminated when not in use, and restarted when it's next needed, so you cannot rely on global state within a service worker's onfetch and onmessage handlers. If there is information that you need to persist and reuse across restarts, service workers do have access to the IndexedDB API.</li><li>Service workers make extensive use of promises, so if you're new to promises, then you should stop reading this and check out Promises, an introduction.</li></ul></p>",
        "image": ""
      },
      {
        "text": "<b>The service worker life cycle</b><p>A service worker has a lifecycle that is completely separate from your web page.</p><p>To install a service worker for your site, you need to register it, which you do in your page's JavaScript. Registering a service worker will cause the browser to start the service worker install step in the background.<p>When installed, the activation step will follow and this is a great opportunity for handling any management of old caches, which we'll cover during the service worker update section.</p><p>After the activation step, the service worker will control all pages that fall under its scope, though the page that registered the service worker for the first time won't be controlled until it's loaded again. Once a service worker is in control, it will be in one of two states: either the service worker will be terminated to save memory, or it will handle fetch and message events that occur when a network request or message is made from your page.</p><p>Below is an overly simplified version of the service worker lifecycle on its first installation:</p>",
        "image": "../assets/image/it/other/sw-lifecycle.png"
      },
      {
        "text": "<b>Push Notification</b><p>Web push notifications allow users to opt-in to timely updates from sites they love and allow you to effectively re-engage them with customized, relevant content.</p><p>The Push API and Notification API open a whole new set of possibilities for you to re-engage with your users.</p>",
        "image": ""
      },
      {
        "text": "<p>Push is based on service workers because service workers operate in the background. This means the only time code is run for a push notification (in other words, the only time the battery is used) is when the user interacts with a notification by clicking it or closing it. If you're not familiar with them, check out the service worker introduction. We will use service worker code in later sections when we show you how to implement pushes and notifications.</p>",
        "image": ""
      },
      {
        "text": "<b>Two technologies</b><p>Push and notification use different, but complementary, APIs: push is invoked when a server supplies information to a service worker; a notification is the action of a service worker or web page script showing information to a user.</p>",
        "image": ""
      }
    ]
  }
]