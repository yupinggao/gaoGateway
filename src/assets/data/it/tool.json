[
  {
    "id": 5,
    "date": "2018/12/30",
    "title": "GIT",
    "itemList": [
      {
        "text": "Git is a version-control system for tracking changes in computer files and coordinating work on those files among multiple people. It is primarily used for source-code management in software development, but it can be used to keep track of changes in any set of files. As a distributed revision-control system, it is aimed at speed, data integrity, and support for distributed, non-linear workflows.",
        "image": ""
      },
      {
        "text": "To check if the git is installed, type <mark>git --version</mark> in a terminal",
        "image": ""
      }
      ,
      {
        "text": "<b>Some GIT Commands</b> <p><mark>git config --global user.email 'email@example.com': </mark>Set the email address in GIT</p><p><mark>git config --list: </mark>show the global config in GIT</p><p><mark>git add: </mark>Add one or more files to staging (index).<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To add one file: git add <i>filename</i><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To stage all changes: git add -A<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To stage modifications and deletions, without new files: git add -u<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To add all new and modified files (without deletion, not including files/folders listed in .gitignore): git add .</p> <p><mark>git commit: </mark>Commit changes.<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commit changes to head (but not yet to the remote repository): git commit -m 'Commit message'<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commit any files you've added with git add, and also commit any files you've changed since then: git commit -a</p> <p><mark>git config: </mark>Configure the author name and email address to be used with your commits. Note that Git strips some characters (for example trailing periods) from user.name.</p> <p><mark>git clone: </mark>Check out a repository.<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To ceate a working copy of a local repository: git clone /path/to/repository<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For a remote server, use: git clone username@host:/path/to/repository</p> <p><mark>git init: </mark>Create a new local repository.</p> <p><mark>git push origin master: </mark>Send changes to the master branch of your remote repository.</p> <p><mark>git status: </mark>List the files you've changed and those you still need to add or commit.</p> <p><mark>git remote add origin <server>: </mark>If you haven't connected your local repository to a remote server, add the server to be able to push to it.<p> <p>For more GIT commands, please visit the following link: <a href='https://git-scm.com/docs' target='_blank'>List Of GIT Commands</a></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 10,
    "date": "2019/01/03",
    "title": "Jenkins",
    "itemList": [
      {
        "text": "<p>Jenkins is an open source automation server written in Java. Jenkins helps to automate the non-human part of the software development process, with continuous integration and facilitating technical aspects of continuous delivery. It is a server-based system that runs in servlet containers such as Apache Tomcat. It supports version control tools, including AccuRev, CVS, Subversion, Git, Mercurial, Perforce, TD/OMS, ClearCase and RTC, and can execute Apache Ant, Apache Maven and sbt based projects as well as arbitrary shell scripts and Windows batch commands.</p><p>Jenkins can be installed through native system packages, Docker, or even run standalone by any machine with a Java Runtime Environment (JRE) installed.</p>",
        "image": ""
      },
      {
        "text": "Builds can be triggered by various means, for example by commit in a version control system, by scheduling via a cron-like mechanism and by requesting a specific build URL. It can also be triggered after the other builds in the queue have completed. Jenkins functionality can be extended with plugins.",
        "image": ""
      },
      {
        "text": "<b>Jenkins Pipeline</b><br/><p>Jenkins Pipeline (or simply 'Pipeline') is a suite of plugins which supports implementing and integrating continuous delivery pipelines into Jenkins.<p>A continuous delivery pipeline is an automated expression of your process for getting software from version control right through to your users and customers.</p><p>Jenkins Pipeline provides an extensible set of tools for modeling simple-to-complex delivery pipelines 'as code'. The definition of a Jenkins Pipeline is typically written into a text file (called a Jenkinsfile) which in turn is checked into a project’s source control repository.</p><p>Figure below shows a diagram of all the sections you can have in a Declarative Pipeline. The way to read this chart is that items with solid line borders are required, and items with dotted line borders are optional:</p>",
        "image": "../assets/image/it/tool/jenkinsPipeline.png",
        "imageClass": "mx-auto d-block"
      }
    ]
  },
  {
    "id": 20,
    "date": "2019/01/06",
    "title": "Gira",
    "itemList": [
      {
        "text": "<p>Jira is a proprietary issue tracking product developed by Atlassian that allows bug tracking and agile project management.</p>",
        "image": ""
      },
      {
        "text": "<p>For remote procedure calls (RPC), Jira supports REST, SOAP, and XML-RPC. Jira integrates with source control programs such as Clearcase, Concurrent Versions System (CVS), Git, Mercurial, Perforce, Subversion, and Team Foundation Server.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 30,
    "date": "2019/03/02",
    "title": "Gradle",
    "itemList": [
      {
        "text": "<b>Some Gradle Commands</b> <p><ul><li><mark>gradlew init: </mark>command to generate a simple project</li><li><mark>gradlew tasks: </mark>lists Gradle tasks that you can invoke, including those added by the base plugin, and custom tasks as well</li><li><mark>gradlew properties: </mark>tells you about a project’s attributes</li><li><mark>gradle wrapper: </mark>generates the necessary Wrapper files in the project directory. The recommended way to execute any Gradle build is with the help of the Gradle Wrapper (in short just “Wrapper”). The Wrapper is a script that invokes a declared version of Gradle, downloading it beforehand if necessary. As a result, developers can get up and running with a Gradle project quickly without having to follow manual installation processes saving your company time and money.</li><li><mark>gradle -q xxx:</mark> the flag -q suppresses Gradle's log messages.</li></ul></p>",
        "image": ""
      },
      {
        "text": "<b>Some Gradle Task Examples</b> <p><ul><li>task copy(type: Copy, group: 'Custom', description: 'Copies sources to the dest directory') {<br/>&emsp;&emsp;from 'src'<br/>&emsp;&emsp;into 'dest'<br/>}</li><li>task zip(type: Zip, group: 'Archive', description: 'Archives sources in a zip file') {<br/>&emsp;&emsp;from 'src'<br/>&emsp;&emsp;setArchiveName 'basic-demo-1.0.zip'<br/>}</li></ul></p>",
        "image": ""
      },
      {
        "text": "<b>Dependency management</b> <p><ul><li><b>compile(Deprecated): </b>Compile time dependencies. Superseded by implementation</li><li><b>implementation extends compile: </b>Implementation only dependencies</li><li><b>compileOnly: </b>Compile time only dependencies, not used at runtime</li><li><b>compileClasspath extends compile, compileOnly, implementation: </b>Compile classpath, used when compiling source. Used by task compileJava</li><li><b>annotationProcessor: </b>Annotation processors used during compilation</li><li><b>runtime(Deprecated) extends compile: </b>Runtime dependencies. Superseded by runtimeOnly</li><li><b>runtimeOnly: </b>Runtime only dependencies</li><li><b>runtimeClasspath extends runtimeOnly, runtime, implementation: </b>Runtime classpath contains elements of the implementation, as well as runtime only elements</li><li><b>testCompile(Deprecated) extends compile: </b>Additional dependencies for compiling tests. Superseded by testImplementation</li><li><b>testImplementation extends testCompile, implementation: </b>Implementation only dependencies for tests</li><li><b>testCompileOnly: </b>Additional dependencies only for compiling tests, not used at runtime</li><li><b>testCompileClasspath extends testCompile, testCompileOnly, testImplementation: </b>Test compile classpath, used when compiling test sources. Used by task compileTestJava</li><li><b>testRuntime(Deprecated) extends runtime, testCompile: </b>Additional dependencies for running tests only. Superseded by testRuntimeOnly</li><li><b>testRuntimeOnly extends runtimeOnly: </b>Runtime only dependencies for running tests</li><li><b>testRuntimeClasspath extends testRuntimeOnly, testRuntime, testImplementation: </b>Runtime classpath for running tests. Used by task test</li><li><b>archives: </b>Artifacts (e.g. jars) produced by this project. Used by task uploadArchives</li><li><b>default extends runtime: </b>The default configuration used by a project dependency on this project. Contains the artifacts and dependencies required by this project at runtime</li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 40,
    "date": "2019/03/03",
    "title": "Gretty",
    "itemList": [
      {
        "text": "<b>Gretty: </b> Gretty is a feature-rich gradle plugin for running web-apps on embedded servlet containers. It supports Jetty versions 7, 8 and 9, Tomcat versions 7 and 8, multiple web-apps and many more. It wraps servlet container functions as convenient Gradle tasks and configuration DSL. Gretty supports web-apps of various types: gradle projects, WAR-files in the file system and even WAR-files from maven dependencies. The central concept of Multiple web-apps feature is farm - a collection of web-apps, that should run together. There are two ways to define and use farms: <ul><li>Default farm is automatically created for you by Gretty. You may add artbitrary web-apps to it and then invoke farm-specific tasks: farmRun, farmRunDebug, etc. Note that farm-specific tasks are not using gretty tasks (appRun, appRunDebug, etc.).</li><li>Named farms, which you create yourself in gradle script. You can add as many named farms as you want, and you can add web-apps to farms in arbitrary constellations. Each named farm provides a specific set of farm tasks. For example, if you define farm with name 'XYZ', there will be new tasks farmRunXYZ, farmRunDebugXYZ, etc. available.</li></ul>",
        "image": ""
      },
      {
        "text": "<b>Some Gretty Task Examples</b> <p><ul><li><mark>appRun task: </mark>appRun task starts web-app inplace, in interactive mode.<br/>Effects:<ol><li>The web-app gets compiled (if it’s not up-to-date).</li><li>Embedded servlet-container starts in separate java process against compiled classes and their dependencies and listens for HTTP-requests on port (default 8080).</li><li>Gretty waits for the user keypress.</li><li>When user presses any key (in the same terminal), servlet-container process shuts down.</li><li>Gretty waits for servlet-container process to complete.</li><li>Gradle script continues normal execution of tasks.</li></ol></li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 50,
    "date": "2019/01/10",
    "title": "Unix/Linux Commands",
    "itemList": [
      {
        "text": "<ul><li><b>find: </b>Find files</li><li><b>grep: </b>Search text for a pattern</li><li><b>ps: </b>Report process status</li><li><b>pwd: </b>tells you where you currently are</li><li><b>chmod: </b>lets you change the read, write, and execute permissions on your files</li><li><b>whoami: </b>returns your username</li><li><b>who: </b>tells you who's logged on, and where they're coming from</li><li><b>ps -u yourusername: </b>lists the user's processes</li><li><b>passwd: </b>change password</li><li><b>Nohup: </b>stands for no hang up. Nohup is very helpful when you have to execute a shell-script or command that take a long time to finish. In that case, you don't want to be connected to the shell and waiting for the command to complete.</li><li><b>netstat --listen or netstat -l: </b>to find open ports</li></ul>",
        "image": ""
      },
      {
        "text": "<p>Find OS: <code>cat /etc/os-release</code></p><p>find kernel version: <code>uname -r</code></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 50,
    "date": "2019/01/26",
    "title": "Webseal",
    "itemList": [
      {
        "text": "<p>WebSEAL is a high performance, multi-threaded Web server that applies fine-grained security policy to resources in the Security Access Manager protected Web object space. WebSEAL can provide single signon solutions and incorporate back-end Web application server resources into its security policy.</p><p>WebSEAL normally acts as a reverse Web proxy by receiving HTTP/HTTPS requests from a Web browser and delivering content from its own Web server or from junctioned back-end Web application servers. Requests passing through WebSEAL are evaluated by the Security Access Manager authorization service to determine whether the user is authorized to access the requested resource.</p>",
        "image": ""
      },
      {
        "text": "",
        "image": ""
      }
    ]
  },
  {
    "id": 60,
    "date": "2019/03/17",
    "title": "Dataweave",
    "itemList": [
      {
        "text": "<p><b>DataWeave Types</b><br/>DataWeave functions operate on data of many types, including <ul><li>Arrays</li><li>Booleans</li><li>CData</li><li>Date and Time</li><li>Enum</li><li>Iterator</li><li>Number</li><li>Object</li><li>Regex</li><li>String</li><li>TryResult</li></ul>The types that DataWeave provide are bundled into modules that also contain the related functions.</p>",
        "image": ""
      },
      {
        "text": "",
        "image": ""
      }
    ]
  },
  {
    "id": 70,
    "date": "2019/03/23",
    "title": "Tomcat",
    "itemList": [
      {
        "text": "<p><b>Configure DataSource in JNDI context</b><br/>Apache Tomcat provide three ways to configure DataSource in JNDI context.<ol><li><b>Application context.xml</b> – This is the easiest way to configure DataSource, all we need is a context.xml file in META-INF directory. We have to define Resource element in the context file and container will take care of loading and configuring it. The approach is simple but it has some drawbacks.<ul><li>Since the context file is bundled with the WAR file, we need to build and deploy new WAR for every small configuration change. Same issue comes if your application works in distributed environment or your application needs to be deployed in different testing environments such as QA, IT, PROD etc.</li><li>The datasource is created by container for the application usage only, so it can’t be used globally. We can’t share the datasource across multiple applications.</li><li>If there is a global datasource (server.xml) defined with same name, the application datasource is ignored.</li></ul></li><li><b>Server context.xml</b> – If there are multiple applications in the server and you want to share DataSource across them, we can define that in the server context.xml file. This file is located in apache-tomcat/conf directory. The scope of server context.xml file is application, so if you define a DataSource connection pool of 100 connections and there are 20 applications then the datasource will be created for each of the application. This will result in 2000 connections that will obviously consume all the database server resources and hurt application performance.</li><li><b>server.xml and context.xml</b> – We can define DataSource at global level by defining them in the server.xml GlobalNamingResources element. If we use this approach, then we need to define a ResourceLink from context.xml file of server or application specific. This is the preferred way when you are looking to share a common resource pool across multiple applications running on the server. Regarding resource link, whether to define it at server level context xml file or application level depends on your requirement.</li></ol></p>",
        "image": ""
      },
      {
        "text": "",
        "image": ""
      }
    ]
  },
  {
    "id": 80,
    "date": "2019/10/29",
    "title": "JBoss AS/WildFly/JBossEAP",
    "itemList": [
      {
        "text": "<p><b>WildFly</b><br/>WildFly, formerly known as JBoss AS, or simply JBoss, is a free and open-source application server authored by JBoss, now developed by Red Hat. WildFly is written in Java and implements the Java Platform, Enterprise Edition (Java EE) specification. It runs on multiple platforms.</p>",
        "image": ""
      },
      {
        "text": "<p><b>JBoss EAP</b><br/>JBoss Enterprise Application platform is a subscription based, Red Hat's supported application server. JBoss EAP is still an opensource project but if you want to use JBoss EAP in production with Red Hat's support, then you need to activate a subscription.</p>",
        "image": ""
      },
      {
        "text": "<p>In general terms, the following tables summarizes the version of WildFly used as baseline for a JBoss EAP version:</p>",
        "image": "../assets/image/it/tool/jboss.png"
      }
    ]
  },
  {
    "id": 200,
    "date": "2019/10/29",
    "title": "Acronyms",
    "itemList": [
      {
        "text": "<p><ol><li><b>ACI</b> - Azure Container Instances</li><li><b>ACR</b> - Azure Container Registry</li><li><b>APM</b> - Application performance monitoring</li><li><b>BBS</b> - Bulletin Board System</li><li><b>CDI</b> – Context and Dependency Injection</li><li><b>CDN</b> – Content Delivery Network</li><li><b>CNI</b> – Container Network Interface</li><li><b>CRD</b> – Custom Resource Definition</li><li><b>CNM</b> – Container Network Model</li><li><b>cURL</b> - Client URL Request Library</li><li><b>HPA</b> - Horizontal Pod Autoscaler</li><li><b>LRP</b> - Long-Running Process</li><li><b>NTP</b> - Network Time Protocol</li><li><b>PVC</b> - Persistent Volume Claim</li><li><b>S2S</b> - Site to Site</li><li><b>UAA</b> - User Account and Authentication</li><li><b>WAF</b> - web application firewall</li></ol></p>",
        "image": ""
      },
      {
        "text": "",
        "image": ""
      }
    ]
  },
  {
    "id": 210,
    "date": "2019/12/10",
    "title": "Azure CLI",
    "itemList": [
      {
        "text": "<p><code>az group create --name myResourceGroup --location eastus</code></p>",
        "image": ""
      },
      {
        "text": "<p><code>az vm create --resource-group myResourceGroup --name myVM --image UbuntuLTS --admin-username azureuser --generate-ssh-keys</code></p>",
        "image": ""
      },
      {
        "text": "<p>Find public IP address:<br><code>az network public-ip list --resource-group myResourceGroup --query [].ipAddress</code></p>",
        "image": ""
      },
      {
        "text": "<p><code>ssh azureuser@40.87.62.106</p>",
        "image": ""
      },
      {
        "text": "<p>Open port 5601 from the Azure CLI to allow remote access:<br><code>az vm open-port --port 5601 --resource-group myResourceGroup --name myVM</code></p>",
        "image": ""
      },
      {
        "text": "<p>Obtain your Azure subscription ID:<br><code>echo sub=$(az account show --query 'id' -o tsv)</code></p>",
        "image": ""
      }
    ]
  }
]