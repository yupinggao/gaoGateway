[
  {
    "id": 5,
    "date": "2018/12/30",
    "title": "GIT",
    "itemList": [
      {
        "text": "Git is a version-control system for tracking changes in computer files and coordinating work on those files among multiple people. It is primarily used for source-code management in software development, but it can be used to keep track of changes in any set of files. As a distributed revision-control system, it is aimed at speed, data integrity, and support for distributed, non-linear workflows.",
        "image": ""
      },
      {
        "text": "To check if the git is installed, type <mark>git --version</mark> in a terminal",
        "image": ""
      }
      ,
      {
        "text": "<b>Some GIT Commands</b> <p><mark>git config --global user.email 'email@example.com': </mark>Set the email address in GIT</p><p><mark>git config --list: </mark>show the global config in GIT</p><p><mark>git add: </mark>Add one or more files to staging (index).<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To add one file: git add <i>filename</i><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To stage all changes: git add -A<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To stage modifications and deletions, without new files: git add -u<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To add all new and modified files (without deletion, not including files/folders listed in .gitignore): git add .</p> <p><mark>git commit: </mark>Commit changes.<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commit changes to head (but not yet to the remote repository): git commit -m 'Commit message'<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Commit any files you've added with git add, and also commit any files you've changed since then: git commit -a</p> <p><mark>git config: </mark>Configure the author name and email address to be used with your commits. Note that Git strips some characters (for example trailing periods) from user.name.</p> <p><mark>git clone: </mark>Check out a repository.<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To ceate a working copy of a local repository: git clone /path/to/repository<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For a remote server, use: git clone username@host:/path/to/repository</p> <p><mark>git init: </mark>Create a new local repository.</p> <p><mark>git push origin master: </mark>Send changes to the master branch of your remote repository.</p> <p><mark>git status: </mark>List the files you've changed and those you still need to add or commit.</p> <p><mark>git remote add origin <server>: </mark>If you haven't connected your local repository to a remote server, add the server to be able to push to it.<p> <p>For more GIT commands, please visit the following link: <a href='https://git-scm.com/docs' target='_blank'>List Of GIT Commands</a></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 10,
    "date": "2019/01/03",
    "title": "Jenkins",
    "itemList": [
      {
        "text": "<p>Jenkins is an open source automation server written in Java. Jenkins helps to automate the non-human part of the software development process, with continuous integration and facilitating technical aspects of continuous delivery. It is a server-based system that runs in servlet containers such as Apache Tomcat. It supports version control tools, including AccuRev, CVS, Subversion, Git, Mercurial, Perforce, TD/OMS, ClearCase and RTC, and can execute Apache Ant, Apache Maven and sbt based projects as well as arbitrary shell scripts and Windows batch commands.</p><p>Jenkins can be installed through native system packages, Docker, or even run standalone by any machine with a Java Runtime Environment (JRE) installed.</p>",
        "image": ""
      },
      {
        "text": "Builds can be triggered by various means, for example by commit in a version control system, by scheduling via a cron-like mechanism and by requesting a specific build URL. It can also be triggered after the other builds in the queue have completed. Jenkins functionality can be extended with plugins.",
        "image": ""
      },
      {
        "text": "<b>Jenkins Pipeline</b><br/><p>Jenkins Pipeline (or simply 'Pipeline') is a suite of plugins which supports implementing and integrating continuous delivery pipelines into Jenkins.<p>A continuous delivery pipeline is an automated expression of your process for getting software from version control right through to your users and customers.</p><p>Jenkins Pipeline provides an extensible set of tools for modeling simple-to-complex delivery pipelines 'as code'. The definition of a Jenkins Pipeline is typically written into a text file (called a Jenkinsfile) which in turn is checked into a project’s source control repository.</p><p>Figure below shows a diagram of all the sections you can have in a Declarative Pipeline. The way to read this chart is that items with solid line borders are required, and items with dotted line borders are optional:</p>",
        "image": "../assets/image/it/tool/jenkinsPipeline.png",
        "imageClass": "mx-auto d-block"
      }
    ]
  },
  {
    "id": 20,
    "date": "2019/01/06",
    "title": "Gira",
    "itemList": [
      {
        "text": "<p>Jira is a proprietary issue tracking product developed by Atlassian that allows bug tracking and agile project management.</p>",
        "image": ""
      },
      {
        "text": "<p>For remote procedure calls (RPC), Jira supports REST, SOAP, and XML-RPC. Jira integrates with source control programs such as Clearcase, Concurrent Versions System (CVS), Git, Mercurial, Perforce, Subversion, and Team Foundation Server.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 30,
    "date": "2019/03/02",
    "title": "Gradle",
    "itemList": [
      {
        "text": "<b>Some Gradle Commands</b> <p><ul><li><mark>gradlew init: </mark>command to generate a simple project</li><li><mark>gradlew tasks: </mark>lists Gradle tasks that you can invoke, including those added by the base plugin, and custom tasks as well</li><li><mark>gradlew properties: </mark>tells you about a project’s attributes</li><li><mark>gradle wrapper: </mark>generates the necessary Wrapper files in the project directory. The recommended way to execute any Gradle build is with the help of the Gradle Wrapper (in short just “Wrapper”). The Wrapper is a script that invokes a declared version of Gradle, downloading it beforehand if necessary. As a result, developers can get up and running with a Gradle project quickly without having to follow manual installation processes saving your company time and money.</li></ul></p>",
        "image": ""
      },
      {
        "text": "<b>Some Gradle Task Examples</b> <p><ul><li>task copy(type: Copy, group: 'Custom', description: 'Copies sources to the dest directory') {<br/>&emsp;&emsp;from 'src'<br/>&emsp;&emsp;into 'dest'<br/>}</li><li>task zip(type: Zip, group: 'Archive', description: 'Archives sources in a zip file') {<br/>&emsp;&emsp;from 'src'<br/>&emsp;&emsp;setArchiveName 'basic-demo-1.0.zip'<br/>}</li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 40,
    "date": "2019/03/03",
    "title": "Gretty",
    "itemList": [
      {
        "text": "<b>Gretty: </b> Gretty is a feature-rich gradle plugin for running web-apps on embedded servlet containers. It supports Jetty versions 7, 8 and 9, Tomcat versions 7 and 8, multiple web-apps and many more. It wraps servlet container functions as convenient Gradle tasks and configuration DSL. Gretty supports web-apps of various types: gradle projects, WAR-files in the file system and even WAR-files from maven dependencies. The central concept of Multiple web-apps feature is farm - a collection of web-apps, that should run together. There are two ways to define and use farms: <ul><li>Default farm is automatically created for you by Gretty. You may add artbitrary web-apps to it and then invoke farm-specific tasks: farmRun, farmRunDebug, etc. Note that farm-specific tasks are not using gretty tasks (appRun, appRunDebug, etc.).</li><li>Named farms, which you create yourself in gradle script. You can add as many named farms as you want, and you can add web-apps to farms in arbitrary constellations. Each named farm provides a specific set of farm tasks. For example, if you define farm with name 'XYZ', there will be new tasks farmRunXYZ, farmRunDebugXYZ, etc. available.</li></ul>",
        "image": ""
      },
      {
        "text": "<b>Some Gretty Task Examples</b> <p><ul><li><mark>appRun task: </mark>appRun task starts web-app inplace, in interactive mode.<br/>Effects:<ol><li>The web-app gets compiled (if it’s not up-to-date).</li><li>Embedded servlet-container starts in separate java process against compiled classes and their dependencies and listens for HTTP-requests on port (default 8080).</li><li>Gretty waits for the user keypress.</li><li>When user presses any key (in the same terminal), servlet-container process shuts down.</li><li>Gretty waits for servlet-container process to complete.</li><li>Gradle script continues normal execution of tasks.</li></ol></li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 50,
    "date": "2019/01/10",
    "title": "Unix Commands",
    "itemList": [
      {
        "text": "<ul><li><b>find: </b>Find files</li><li><b>grep: </b>Search text for a pattern</li><li><b>ps: </b>Report process status</li><li><b>pwd: </b>tells you where you currently are</li><li><b>chmod: </b>lets you change the read, write, and execute permissions on your files</li><li><b>whoami: </b>returns your username</li><li><b>who: </b>tells you who's logged on, and where they're coming from</li><li><b>ps -u yourusername: </b>lists the user's processes</li><li><b>passwd: </b>change password</li><li><b>Nohup: </b>stands for no hang up. Nohup is very helpful when you have to execute a shell-script or command that take a long time to finish. In that case, you don't want to be connected to the shell and waiting for the command to complete.</li><li><b>netstat --listen or netstat -l: </b>to find open ports</li></ul>",
        "image": ""
      },
      {
        "text": "",
        "image": ""
      }
    ]
  },
  {
    "id": 50,
    "date": "2019/01/26",
    "title": "Webseal",
    "itemList": [
      {
        "text": "<p>WebSEAL is a high performance, multi-threaded Web server that applies fine-grained security policy to resources in the Security Access Manager protected Web object space. WebSEAL can provide single signon solutions and incorporate back-end Web application server resources into its security policy.</p><p>WebSEAL normally acts as a reverse Web proxy by receiving HTTP/HTTPS requests from a Web browser and delivering content from its own Web server or from junctioned back-end Web application servers. Requests passing through WebSEAL are evaluated by the Security Access Manager authorization service to determine whether the user is authorized to access the requested resource.</p>",
        "image": ""
      },
      {
        "text": "",
        "image": ""
      }
    ]
  }
]