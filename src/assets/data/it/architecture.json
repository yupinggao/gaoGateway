[
  {
    "id": 5,
    "date": "2015/10/29",
    "title": "EAI",
    "itemList": [
      {
        "text": "<p>Enterprise Application Integration (EAI) is a technical field of Enterprise Architecture, which focused on the study of topics such as system interconnection, electronic data interchange, product data exchange and distributed computing environments.</p><p>It is a concept in Enterprise engineering to provide the right information at the right place and at the right time and thereby enable communication between people, machines and computers and their efficient co-operation and co-ordination.</p><p><b>Enterprise Integration Patterns:</b></p><p><ul><li><b>Channel Patterns:</b> describe the fundamental attributes of a messaging system. These patterns are implemented by most commercial messaging systems. This section focuses on the interrelationships between different features and highlights implementation trade-off made by different vendors.</li>  <li><b>Message Construction Patterns:</b> describe the intent, form and content of the messages that travel across the messaging system. The base pattern for this section is the Message pattern.</li>  <li><b>Routing Patterns:</b> discuss mechanisms to direct messages from a sender to the correct receiver. Message routing patterns consume messages from one channel and republish the message to another channel that is determined by a varying set of conditions. The message content is not modified. The patterns presented in this section are special cases of the Message Router base pattern.</li><li><b>Transformation Patterns:</b> change the information content of a message. In many cases, a message format needs to be changed due to different data formats used by the sending and the receiving system. Data may have to be added, taken away or existing data may have to be rearranged. The base pattern for this section is the Message Translator.</li><li><b>Endpoint Patterns:</b> describe the behavior of messaging system clients. They illustrate different ways in which applications can produce or consume messages.</li><li><b>System Management Patterns:</b> provide the tools to keep a complex message-based system running. A message-based integration solution can process thousands or even millions of messages in a day. Messages are generated, routed, transformed and consumed. The solution has to deal with error conditions, performance bottlenecks and changes in the participating systems. Message management patterns address these requirements.</li></ul>",
        "image": ""
      }
    ]
  },
  {
    "id": 10,
    "date": "2015/10/30",
    "title": "ESB",
    "itemList": [
      {
        "text": "<p>An enterprise service bus (ESB) is a software architecture model used for designing and implementing communication between mutually interacting software applications in a service-oriented architecture (SOA). As a software architectural model for distributed computing it is a specialty variant of the more general client server model and promotes agility and flexibility with regard to communication between applications. Its primary use is in enterprise application integration (EAI) of heterogeneous and complex landscapes.</p><p><b>The Prime Functionalities of ESB:</b></p><p><ul><li>Orchestration</li><li>Data Transformation and Mapping</li><li>Mediation</li><li>Validation</li><li>Routing</li></ul><br/><b>ESB Messaging Patterns:</b></p><p><ul><li>Fire-and-Forget</li><li>Request-Reply</li><li>Aggregation</li><li>Sequential</li></ul>",
        "image": ""
      }
    ]
  },
  {
    "id": 20,
    "date": "2015/10/30",
    "title": "IBM ESB Products",
    "itemList": [
      {
        "text": "<b>WebSphere Message Broker</b><p>WebSphere Message Broker is an Enterprise Service Bus (ESB) built for universal connectivity and transformation in heterogeneous IT environments. WebSphere Message Broker distributes information and data generated by business events in real time to people, applications, and devices throughout your extended enterprise and beyond.",
        "image": ""
      },
      {
        "text": "<b>WebSphere ESB</b><p>WebSphere Enterprise Service Bus (ESB) is a flexible connectivity infrastructure for integrating applications and services. An ESB provides the connectivity to implement a service-oriented architecture (SOA), reducing the complexity of integrating applications and services. With WebSphere ESB, you can focus on your core business initiatives instead of IT maintenance.",
        "image": ""
      },
      {
        "text": "<b>IBM Integration Bus</b><p>IBM Integration Bus represents IBM's strategic Enterprise Service Bus (ESB) offering and is the successor product for existing clients of both WebSphere Message Broker and WebSphere ESB.<br/>It is IBM's integration broker from the WebSphere product family that allows business information to flow between disparate applications across multiple hardware and software platforms. Rules can be applied to the data flowing through the message broker to route and transform the information. The product is an Enterprise Service Bus providing connectivity between applications and services in a service-oriented architecture.",
        "image": ""
      },
      {
        "text": "<b>IBM Datapower</b><p>IBM WebSphere DataPower SOA Appliances is a family of pre-built, pre-configured rack mountable network devices (XML appliances) that can help accelerate XML and Web Services deployments while extending SOA infrastructure. Originally these devices were created by DataPower Technology Inc., which was acquired by IBM in October 2005.[1]</p><p>This WebSphere family consists of rack-mountable network appliances, blade appliances, appliances that rack inside a z/OS mainframe, and virtual appliances.",
        "image": ""
      },
      {
        "text": "<b>Comparison between IBM WebSphere Message Broker and Datapower</b> (source from: http://middlewareservice.blogspot.ca/2011/06/esb-product-consideration-datapower-vs.html)",
        "image": "../assets/image/it/architecture/embVSDatapower.png"
      }
    ]
  },
  {
    "id": 30,
    "date": "2015/11/1",
    "title": "SOA",
    "itemList": [
      {
        "text": "A service-oriented architecture (SOA) is a software design principle and an architecture pattern for implementing loosely coupled, reusable and coarse grained services.</p><p>SOA can be implemented using many protocols such as HTTP, HTTPS, JMS, SMTP, RMI, IIOP, RPC. Payload can be in many formats, such as XML, JSON and Data Transfer Objects.</p><p>SOA involves the services themselves, a directory of available services in some form (service discovery), and public contracts for consumers to connect and use each service (service negotiation).",
        "image": ""
      },
      {
        "text": "<p>The following three fundamental aspects are part and parcel of SOA:</p><p><ol><li><b>Service:</b> A repeatable business task.</li><li><b>Service Orientation:</b> A way of thinking the business through linked services.</li><li><b>SOA:</b> A business centric architecture.</li></ol>",
        "image": ""
      },
      {
        "text": "<b>Characteristics of SOA:</b><p><ul><li><b>Reuse:</b> SOA is an evolution of the fundamentals governing a component based development. SOA provides even greater code reuse not only by utilizing OO components based development, but also by identifying and organizing well-defined and non-repeatable services into a hierarchy of composite services.</li><li><b>Loosely coupled:</b> SOA comes from loosely coupled application components, in which code is not necessarily tied to a particular database. Loose coupling enables enterprises to plug in or upgrade existing services in a modular fashion to react to new business requirements.</li><li><b>Coarse grained:</b> Business level service.</li><li><b>Services are stateless.</b></li><li><b>Services can be described (WSDL).</b></li><li><b>Services can be Published.</b></li><li><b>Services can be Discovered (discoverability).</b></li><li><b>Services abstraction:</b> the consumers only know the contract without worrying about implementation details.</li><li><b>Standardized service contract.</b></li><li><b>Business Agility.</b></li><li><b>Run-time environment autonomy.</b></li></ul>",
        "image": ""
      },
      {
        "text": "<b>Advantages offered by SOA:</b><p><ul><li>Break down the silos of data, applications, and functionalities into enterprise services.</li><li>Adapts well and fast to changing business needs and technologies changes due to well-defined interfaces.</li><li>Easily integrates applications with other systems in a loosely coupled manner.</li><li>Reuse and improve asset utilization by leveraging existing investments in legacy applications.</li><li>Achieve business agility by quickly and easily creating a business process by leveraging existing services.</li><li>Provides interoperability and multi channel access.</li></ul>",
        "image": ""
      },
      {
        "text": "<b>SOA Basic Patterns:</b><p><ul><li><b>Aggregator:</b> Combines individual messages to be handled as a single unit.</li><li><b>Service Bus:</b> A communications channel for message delivery from a single inbound endpoint to one or more outbound endpoints and optional “on the fly” message processing as data flows through the bus.</li><li><b>Dynamic Routing:</b> An efficient mechanism for dispatching messages to one or more destinations based on configurable, non-filtering rules applied to the message payload.</li><li><b>Event-Driven Consumer:</b> A setup that delivers messages to a services provider as soon as they appear on the channel.</li><li><b>Filter:</b> A conduit that extracts data from a message or applies a function to it as it flows between consumers and services through a messaging channel.</li><li><b>Router:</b> A general mechanism for dispatching messages to one or more destinations based on configurable rules or filters applied to message payloads.</li>  <li><b>Translator or Transformer:</b> A mechanism for converting a message payload from one representation to another as it flows through the messaging system.</li><li><b>Bridge:</b> A mechanism for connecting two or more applications over a common data path, each using a different protocol and in which messages may require processing or analysis as they flow between endpoints for routing.</li></ul>",
        "image": ""
      },
      {
        "text": "<b>SOA Architecture Patterns:</b><p><ul><li><b>Asynchronous Processing:</b> A mechanism for queuing messages between one or more endpoints to decouple processing time and resourcesfor each stage.</li><li><b>Cross-Service Operation: </b> A mechanism for coordinating multiple run-time activities which together comprise a service with guaranteed completion or roll-back capabilities.</li><li><b>Event-Driven Dispatching:</b> A mechanism for routing messages to consumers in response to specific events in the SOA or triggered by specific applications running in the SOA.</li><li><b>Process Aggregation: </b>A method of combining two or more non-sequential, inter-dependent processing steps.</li><li><b>Routing and Filtering: </b> A formal mechanism for routing messages to application endpoints between endpoints.</li><li><b>Replicator:</b> Messages or payloads must be replicated across multiple endpoints with identical configurations.</li></ul>",
        "image": ""
      },
      {
        "text": "<b>Compound Patterns:</b><p><ul><li><b>Centralized Schema:</b> Defines a method of sharing schemas across application boundaries to avoid redundant data representation and service definition.</li><li><b>Concurrent Contracts: </b> Method for allowing multiple consumers with different abstractions or implementations to simultaneously consume the same service.</li><li><b>Decompose Capability:</b> A way of designing services to reduce the impact of functional deconstruction if it becomes necessary due to bloat or evolution of business processes and workflow.</li><li><b>Enterprise Service Bus: </b>A communications channel for message delivery from a single inbound endpoint to one or more outbound endpoints and provides protocol handling, message filtering, transformation, and routing, and optional “on the fly” message processing.</li><li><b>Fault-Tolerant Service Provider: </b> Mechanism for deploying a service platform to achieve near-zero downtime in case one of the services providers or the platform itself have a catastrophic failure.</li><li><b>Wrapper:</b> Encapsulate a legacy service API inside a generic, stateless service.</li></ul>",
        "image": ""
      }
    ]
  },
  {
    "id": 40,
    "date": "2019/02/13",
    "title": "SOAP WS",
    "itemList": [
      {
        "text": "<b>WSDL</b> <br/>An WSDL document describes a web service. It specifies the location of the service, and the methods of the service, using these major elements:<p><ul><li><mark>types: </mark>Defines the (XML Schema) data types used by the web service</li><li><mark>message: </mark>Defines the data elements for each operation</li><li><mark>portType: </mark>Describes the operations that can be performed and the messages involved</li><li><mark>binding: </mark>Defines the protocol and data format for each port type</li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 50,
    "date": "2015/11/7",
    "title": "Restful WS",
    "itemList": [
      {
        "text": " Representational State Transfer (REST) is an architectural style that specifies constraints, such as the uniform interface, that if applied to a web service induce desirable properties, such as performance, scalability, and modifiability, that enable services to work best on the Web. In the REST architectural style, data and functionality are considered resources and are accessed using Uniform Resource Identifiers (URIs), typically links on the Web. The resources are acted upon by using a set of simple, well-defined operations. The REST architectural style constrains an architecture to a client/server architecture and is designed to use a stateless communication protocol, typically HTTP. In the REST architecture style, clients and servers exchange representations of resources by using a standardized interface and protocol.",
        "image": ""
      },
      {
        "text": "The following principles encourage RESTful applications to be simple, lightweight, and fast:<ul><li><b>Resource identification through URI: </b>A RESTful web service exposes a set of resources that identify the targets of the interaction with its clients. Resources are identified by URIs, which provide a global addressing space for resource and service discovery. See The @Path Annotation and URI Path Templates for more information.</li><li><b>Uniform interface: </b>Resources are manipulated using a fixed set of four create, read, update, delete operations: PUT, GET, POST, and DELETE. POST creates a new resource, which can be then deleted by using DELETE. GET retrieves the current state of a resource in some representation. PUT transfers a new state onto a resource. See Responding to HTTP Methods and Requests for more information.<br>PUT and POST are both unsafe methods. However, PUT is idempotent, while POST is not.</li><li><b>Self-descriptive messages: </b>Resources are decoupled from their representation so that their content can be accessed in a variety of formats, such as HTML, XML, plain text, PDF, JPEG, JSON, and others. Metadata about the resource is available and used, for example, to control caching, detect transmission errors, negotiate the appropriate representation format, and perform authentication or access control. See Responding to HTTP Methods and Requests and Using Entity Providers to Map HTTP Response and Request Entity Bodies for more information.</li><li><b>Stateful interactions through hyperlinks: </b>Every interaction with a resource is stateless; that is, request messages are self-contained. Stateful interactions are based on the concept of explicit state transfer. Several techniques exist to exchange state, such as URI rewriting, cookies, and hidden form fields. State can be embedded in response messages to point to valid future states of the interaction. See Using Entity Providers to Map HTTP Response and Request Entity Bodies and Building URI in the JAX-RS Overview document for more information.</li></ul>",
        "image": ""
      },
      {
        "text": "Restful API Operations: <ul><li><b>GET: </b>Retrieves data from the server.</li><li><b>PUT: </b>Updates data that is stored in the server.</li><li><b>POST: </b>Sends data to the server for processing.</li><li><b>DELETE: </b>Removes data from the server.</li><li><b>PATCH: </b>Applies partial modifications to an operation. Unlike the PUT method, the PATCH method applies an incremental change rather than replacing the entire operation.</li><li><b>HEAD: </b>Requests the same response as for a GET method call, but without the response body. This method is useful for retrieving information that is written in response headers, without having to transport the entire content.</li><li><b>OPTIONS: </b>Retrieves the HTTP methods and other options that are supported by a web server or an operation, without implying a resource action or initiating an operation retrieval.</li></ul>",
        "image": ""
      }
    ]
  },
  {
    "id": 60,
    "date": "2019/01/26",
    "title": "JMS",
    "itemList": [
      {
        "text": "<p>The Java Message Service (JMS) API is a Java message-oriented middleware API for sending messages between two or more clients.</p><p>JMS is a part of the Java Platform, Enterprise Edition (Java EE). It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous.</p>",
        "image": ""
      },
      {
        "text": "<p>There are five types of message body: <ul><li>Text</li><li>Map</li><li>Stream</li><li>Object</li><li>Byte</li></ul></p>",
        "image": ""
      },
      {
        "text": "<p>Some properties defined in message header: <ul><li>JMSMessageID</li><li>JMSCorrelationID</li><li>JMSDeliveryMode</li><li>JMSExpiration</li><li>JMSPriority</li></ul></p>",
        "image": "../assets/image/it/architecture/jms.png"
      }
    ]
  },
  {
    "id": 70,
    "date": "2015/11/1",
    "title": "Network Diagram",
    "itemList": [
      {
        "text": "The following is a typical enterprise network diagram (diagram source: https://applicationarchitecture.files.wordpress.com/2010/03/f0022-sample-network-diagram.png):",
        "image": "../assets/image/it/architecture/sampleNetworkDiagram.png"
      }
    ]
  }
]