[
  {
    "id": 100,
    "date": "2020/10/30",
    "title": "Salesforce",
    "itemList": [
      {
        "text": "<p><b>Salesforce Architecture</b><br>When you think about the Salesforce architecture, imagine a series of layers that sit on top of each other. Sometimes it helps to think of it as a cake because cake is delicious, and it makes everything better.</p>",
        "image": "../assets/image/server/otherProduct/salesforceArchitecture.PNG",
        "imageClass": "mx-auto d-block"
      },
      {
        "text": "<p><b>There’s a lot to unpack here, but let’s focus on the most important points.</b><ol><li>Salesforce is a cloud company. Everything we offer resides in the trusted, multitenant cloud.</li><li>The Salesforce platform is the foundation of our services. It’s powered by metadata and made up of different parts, like data services, artificial intelligence, and robust APIs for development.</li><li>All our apps sit on top of the platform. Our prebuilt offerings like Sales Cloud and Marketing Cloud, along with apps you build using the platform, have consistent, powerful functionality.</li><li>Everything is integrated. Our platform technologies like Einstein predictive intelligence and the Lightning framework for development are built into everything we offer and everything you build.</li></ol></p>",
        "image": ""
      },
      {
        "text": "<p><b>Differences Between Salesforce Classic vs Lightning</b><ol><li><b>Enhanced User Experience:</b> One of the major differences between Salesforce Classic and Salesforce Lightning is the user interface. The latter offers a much better user interface experience to its users that includes features like the drag-and-drop functionality that can be achieved without any code. Instead of hiring a Salesforce developer to create a Salesforce page or modify it, the page components can easily be rearranged by an admin according to their liking. <br>Furthermore, Lightning helps in toning down the need for Visualforce for every task. The codes that are created during any kind of development need to be tested and then deployed. In case of missed bugs, the code is sent back to the developer to fix and the process starts over again. But with the help of Salesforce Lightning, these types of tedious processes can be avoided. <br>Lightning does not mean that companies don’t need Visualforce developers anymore. Lightning provides a helping hand to the developers by moving minor customization tasks to the admins, which allows developers to focus on larger Salesforce app development projects.</li><li><b>Higher Security:</b> With Salesforce Lightning comes enhanced security. For instance, LockerService is a feature that separates Lightning components for them to interact with each other. This helps in safeguarding the platform from malicious data. No such feature can be found in the Classic mode.<br>Permissions, too, work quite distinctly in Salesforce Lightning. The platform does not allow users to raise their assurance levels, say from standard to high, in-session. For that, they will have to log out of the Lightning platform and sign in again with authentication with a higher assurance level.</li><li><b>Einstein (Wave) Analytics:</b> While an enhanced and upgraded user interface and security are the points strong enough for the comparison, Salesforce Lightning also provides users with access to Einstein (Wave) Analytics reporting, which the Classic does not. For creating graphs, charts, and lists, the Salesforce Classic reports depend on standard reporting types. At the time the data is refreshed, these dashboards prove to be a great option for capturing a view of important metrics.<br>When we talk about Einstein Analytics, it is a whole different deal. The platform carries its own database that is fetched from Salesforce and updates each hour automatically. Also, the dashboard displays the most recent, refreshed data.</li><li><b>Progressive platform:</b> In its initial days, Lightning was looked down at because of its transition and compatibility issues with objects, custom code, and apps. But gone are those days, and the platform has evolved with the ability to support all custom metadata objects, making it a lot simpler for companies to transition their existing apps and workflows with no requirements of building from scratch.</li><li><b>Hassle-free Lead Generation: </b>Although Salesforce Classic enables you to create leads, the Lightning Experience offers more components in order to manage sales processes better. For instance, the Activity timeline in the Lightning mode allows users to identify what’s been achieved for a specific lead and presents the details of every meeting, task, or call. The Path component enables the tracking of various stages involved in the business process, whereas, the News component offers updates about the leads on time.</li></ol></p>",
        "image": ""
      },
      {
        "text": "<p><b>Aura Components</b><br>Aura components are the self-contained and reusable units of an app. They represent a reusable section of the UI, and can range in granularity from a single line of text to an entire app.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Database in Context of Salesforce</b><br>When we talk about the database, think of a giant spreadsheet. When you put information into Salesforce, it gets stored in the database so you can access it again later. It’s stored in a very specific way so you’re always accessing the information you need.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Metadata</b><br>When you look at data in Salesforce, you might think that you're looking at a user interface sitting on top of a run-of-the-mill relational database. But what you’re actually looking at is an abstraction of the database that’s driven by the platform’s metadata-aware architecture.</p><p>In this abstraction, objects are our database tables. The fields on those objects are columns, and records are rows in the database. This analogy is true both for standard objects that come with Salesforce by default and custom objects that you build yourself.</p><p>In short, metadata forms the structure of your org. Whether you’re defining fields, business processes, or something more complex, metadata holds your configuration. The platform then renders your app’s metadata in the user interface along with its associated data.</p>",
        "image": ""
      },
      {
        "text": "<p><b>No-Code and Low-Code Development</b><br>It can be surprising to hear, but the Salesforce platform encourages you to minimize code. And it’s not because we don’t love code. It’s because the platform’s metadata-driven architecture lets you complete most basic development tasks without ever writing a line.</p><p>Salesforce offers a host of tools for point-and-click—or declarative—development. Most of these tools require little to no understanding of development principles: no code.</p><p>Some development tasks, like writing validation rules or hooking up components with UI elements, are considered low code. That means they require some basic programmatic knowledge to complete, but aren’t so rigorous that they’re considered programmatic. For example, if you know something about logic, conditions, and CRUD operations, you can do more with Process Builder.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Salesforce Security</b><br>The platform makes it easy to specify which users can view, create, edit, or delete any record or field in the app. You can control access to your whole org, a specific object, a specific field, or even an individual record. By combining security controls at different levels, you can provide just the right level of data access to thousands of users without having to specify permissions for each user individually.</p>",
        "image": "../assets/image/server/otherProduct/salesforceSecurity.PNG",
        "imageClass": "mx-auto d-block"
      }
    ]
  },
  {
    "id": 200,
    "date": "2020/11/22",
    "title": "Salesforce Tools",
    "itemList": [
      {
        "text": "<p>Lightning Flow provides declarative process automation for every Salesforce app, experience, and portal.<ul><li>Lightning Flow is the name of the product.</li><li>Process Builder and Flow Builder are the names of the tools.</li><li>Use Process Builder to make processes; use Flow Builder to make flows.</li></ul></p>",
        "image": ""
      },
      {
        "text": "<p><b>Which Automation Tool Is Right for My Use Case?</b><br>When it’s all said and done, a process-driven experience isn’t backed by only one process. It’s a combination of all the business processes in your org that can impact your customer. Each business process typically falls into one of these camps.</p>",
        "image": "../assets/image/server/otherProduct/tools.PNG",
        "imageClass": "mx-auto d-block"
      },
      {
        "text": "<p><b>Automation Tools</b><p>One of the hardest things for an admin or a developer to figure out is when to use what tool for the job at hand. In general, it’s best to start with declarative, no-code tools and work your way up to code solutions.</p><ul><li><b>Process Builder:</b> Use Process Builder when you need to start a behind-the-scenes business process automatically. Processes can start when:<br><ul><li>A record is created</li><li>A record is updated</li><li>A platform event occurs</li></ul></li><li><b>Flow Builder:</b> Use Flow Builder to:<ul><li>Automate a guided visual experience</li><li>Add more functionality for a behind-the-scenes process than is available in Process Builder. Use Flow Builder to build the more complex functionality. Then call the resulting flow from the process</li><li>Start a behind-the-scenes business process:<ul><li>When a user clicks something, like a button</li><li>When a record is created</li><li>When a record is updated</li><li>When a platform event occurs</li><li>At a specified time and frequency</li></ul></li></ul></li><li><b>Approvals:</b> Approvals isn’t included in Lightning Flow, but it offers a declarative way to automate something that Lightning Flow doesn’t cover. That said, Lightning Flow does support automating how a record gets submitted for approval.</li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 300,
    "date": "2020/11/24",
    "title": "Salesforce Data Security",
    "itemList": [
      {
        "text": "<p><b>Levels of Data Access</b><p>You can control which users have access to which data in your whole org, a specific object, a specific field, or an individual record.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Organization</b><p>For your whole org, you can maintain a list of authorized users, set password policies, and limit logins to certain hours and locations.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Objects</b><p>Access to object-level data is the simplest thing to control. By setting permissions on a particular type of object, you can prevent a group of users from creating, viewing, editing, or deleting any records of that object. For example, you can use object permissions to ensure that interviewers can view positions and job applications but not edit or delete them.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Fields</b><p>You can restrict access to certain fields, even if a user has access to the object. For example, you can make the salary field in a position object invisible to interviewers but visible to hiring managers and recruiters.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Records</b><p>You can allow particular users to view an object, but then restrict the individual object records they're allowed to see. For example, an interviewer can see and edit her own reviews, but not the reviews of other interviewers. You can manage record-level access in these four ways.</p>",
        "image": ""
      },
      {
        "text": "<p><ul><li><b>Organization-wide defaults</b> specify the default level of access users have to each others’ records. You use org-wide sharing settings to lock down your data to the most restrictive level, and then use the other record-level security and sharing tools to selectively give access to other users.</li><li><b>Role hierarchies</b> give access for users higher in the hierarchy to all records owned by users below them in the hierarchy. Role hierarchies don’t have to match your organization chart exactly. Instead, each role in the hierarchy should represent a level of data access that a user or group of users needs.</li><li><b>Sharing rules</b> are automatic exceptions to organization-wide defaults for particular groups of users, so they can get to records they don’t own or can’t normally see. Sharing rules, like role hierarchies, are only used to give additional users access to records. They can’t be stricter than your organization-wide default settings.</li><li><b>Manual sharing</b> allows owners of particular records to share them with other users. Although manual sharing isn’t automated like org-wide sharing settings, role hierarchies, or sharing rules, it can be useful in some situations, such as when a recruiter going on vacation needs to temporarily assign ownership of a job application to someone else.</li></ul></p>",
        "image": ""
      },
      {
        "text": "<p><b>Manage Object Permissions</b><p>The simplest way to control data access is to set permissions on a particular type of object. (An object is a collection of records, like leads or contacts.) You can control whether a group of users can create, view, edit, or delete any records of that object.</p><p>You can set object permissions with profiles or permission sets. A user can have one profile and many permission sets.<ul><li>A user’s profile determines the objects they can access and the things they can do with any object record (such as create, read, edit, or delete).</li><li>Permission sets grant additional permissions and access settings to a user.</li></ul></p><p>Use profiles to grant the minimum permissions and settings that all users of a particular type need. Then use permission sets to grant more permissions as needed. The combination of profiles and permission sets gives you a great deal of flexibility in specifying object-level access.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Use Profiles to Restrict Access</b><p>Each user has a single profile that controls which data and features that user has access to. A profile is a collection of settings and permissions. Profile settings determine which data the user can see, and permissions determine what the user can do with that data.<ul><li>The settings in a user’s profile determine whether the user can see a particular app, tab, field, or record type.</li><li>The permissions in a user’s profile determine whether the user can create or edit records of a given type, run reports, and customize the app.</li></ul></p><p>Profiles usually match up with a user's job function (for example, system administrator, recruiter, or hiring manager), but you can have profiles for anything that makes sense for your Salesforce org. A profile can be assigned to many users, but a user can have only one profile at a time.</p>",
        "image": ""
      },
      {
        "text": "<p>Users can have only one profile, but they can have multiple permission sets.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 400,
    "date": "2020/11/26",
    "title": "Salesforce Dashboard",
    "itemList": [
      {
        "text": "<p>A dashboard is a visual display of key metrics and trends for records in your org. The relationship between a dashboard component and report is 1:1; for each dashboard component, there is a single source report. However, you can use the same report in multiple dashboard components on a single dashboard (for example, use the same report in both a bar chart and pie chart). You can display multiple dashboard components on a single dashboard page, creating a powerful visual display and a way to consume multiple reports that often have a common theme, like sales performance or customer support.</p>",
        "image": ""
      },
      {
        "text": "<p>Like reports, dashboards are stored in folders, which control who has access. If you have access to a folder, you can view its dashboards. However, to view the dashboard components, you need access to the underlying reports as well.</p>",
        "image": ""
      },
      {
        "text": "<p>Each dashboard has a running user, whose security settings determine which data to display in a dashboard. If the running user is a specific user, all dashboard viewers see data based on the security settings of that user—regardless of their own personal security settings. For this reason, you’ll want to choose the running user wisely, so as not to open up too much visibility. For example, set the sales manager as the running user for a leaderboard for her team. This allows her team members to view the leaderboard for their individual team, but not other teams.</p>",
        "image": ""
      },
      {
        "text": "<p>Dynamic dashboards are dashboards for which the running user is always the logged-in user. This way, each user sees the dashboard according to his or her own access level. If you’re concerned about too much access, dynamic dashboards might be the way to go.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 500,
    "date": "2020/11/28",
    "title": "Salesforce Object",
    "itemList": [
      {
        "text": "<b>Relationships Among Objects</b><p><ul><li>Master-Detail (1:n) — A parent-child relationship in which the master object controls certain behaviors of the detail object.</li><li>Many-to-many — You can use master-detail relationships to model many-to-many relationships between any two objects</li><li>Lookup (1:n) — This type of relationship links two objects together, but has no effect on deletion or security. Unlike master-detail fields, lookup fields are not automatically required. When you define a lookup relationship, data from one object can appear as a custom related list on page layouts for the other object.</li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 600,
    "date": "2020/11/28",
    "title": "Salesforce DML",
    "itemList": [
      {
        "text": "<p>Apex contains the built-in Database class, which provides methods that perform DML operations and mirror the DML statement counterparts.</p><p>Unlike DML statements, Database methods have an optional allOrNone parameter that allows you to specify whether the operation should partially succeed. When this parameter is set to false, if errors occur on a partial set of records, the successful records will be committed and errors will be returned for the failed records. Also, no exceptions are thrown with the partial success option.</p>",
        "image": ""
      },
      {
        "text": "<b>Should You Use DML Statements or Database Methods?</b><p><ul><li>Use DML statements if you want any error that occurs during bulk DML processing to be thrown as an Apex exception that immediately interrupts control flow (by using try. . .catch blocks). This behavior is similar to the way exceptions are handled in most database procedural languages.</li><li>Use Database class methods if you want to allow partial success of a bulk DML operation—if a record fails, the remainder of the DML operation can still succeed. Your application can then inspect the rejected records and possibly retry the operation. When using this form, you can write code that never throws DML exception errors. Instead, your code can use the appropriate results array to judge success or failure. Note that Database methods also include a syntax that supports thrown exceptions, similar to DML statements.</li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 700,
    "date": "2020/12/11",
    "title": "SOQL",
    "itemList": [
      {
        "text": "<p>Instead of using the equal operator (=) for comparison, you can perform fuzzy matches by using the LIKE operator. For example, you can retrieve all accounts whose names start with SFDC by using this condition: WHERE Name LIKE 'SFDC%'. The % wildcard character matches any or no character. The _ character in contrast can be used to match just one character.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 800,
    "date": "2020/11/27",
    "title": "Apex",
    "itemList": [
      {
        "text": "<p>Apex is a case-insensitive language.</p><p>Apex is tightly integrated with the database, you can access Salesforce records and their fields directly from Apex. Every record in Salesforce is natively represented as an sObject in Apex.</p>",
        "image": ""
      },
      {
        "text": "<p>Unlike specific sObjects types, generic sObjects can be created only through the newSObject() method. Also, the fields of a generic sObject can be accessed only through the put() and get() methods.</p><p>You can delete persisted records using the delete statement. Deleted records aren’t deleted permanently from Lightning Platform, but they’re placed in the Recycle Bin for 15 days from where they can be restored.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 900,
    "date": "2020/12/12",
    "title": "Apex Triggers",
    "itemList": [
      {
        "text": "<p>To access the records that caused the trigger to fire, use context variables. For example, Trigger.New contains all the records that were inserted in insert or update triggers. Trigger.Old provides the old version of sObjects before they were updated in update triggers, or a list of deleted sObjects in delete triggers. Triggers can fire when one record is inserted, or when many records are inserted in bulk via the API or Apex. Therefore, context variables, such as Trigger.New, can contain only one record or multiple records. You can iterate over Trigger.New to get each individual sObject.</p>",
        "image": ""
      },
      {
        "text": "<p>The system saves the records that fired the before trigger after the trigger finishes execution. You can modify the records in the trigger without explicitly calling a DML insert or update operation. If you perform DML statements on those records, you get an error.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Trigger Context Variables</b></p>",
        "image": "../assets/image/server/otherProduct/triggerContextVariabe.PNG",
        "imageClass": "mx-auto d-block"
      },
      {
        "text": "<p><b>Triggers and Callouts</b><br>Apex allows you to make calls to and integrate your Apex code with external Web services. Apex calls to external Web services are referred to as callouts. For example, you can make a callout to a stock quote service to get the latest quotes. When making a callout from a trigger, the callout must be done asynchronously so that the trigger process doesn’t block you from working while waiting for the external service's response.The asynchronous callout is made in a background process, and the response is received when the external service returns it.</p><p>To make a callout from a trigger, call a class method that executes asynchronously. Such a method is called a future method and is annotated with @future(callout=true). This example class contains the future method that makes the callout.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1000,
    "date": "2020/11/29",
    "title": "Apex Test",
    "itemList": [
      {
        "text": "<p>Salesforce records that are created in test methods aren’t committed to the database. They’re rolled back when the test finishes execution. This rollback behavior is handy for testing because you don’t have to clean up your test data after the test executes.</p><p>Whenever you modify your Apex code, rerun your tests to refresh code coverage results.</p><p>A known issue with the Developer Console prevents it from updating code coverage correctly when running a subset of tests. To update your code coverage results, use Test | Run All rather than Test | New Run.</p><p>By default, Apex tests don’t have access to pre-existing data in the org, except for access to setup and metadata objects, such as the User or Profile objects. Set up test data for your tests. Creating test data makes your tests more robust and prevents failures that are caused by missing or changed data in the org. You can create test data directly in your test method, or by using a utility test class as you’ll find out later.</p><p>Even though it is not a best practice to do so, there are times when a test method needs access to pre-existing data. To access org data, annotate the test method with @isTest(SeeAllData=true). The test method examples in this unit don’t access org data and therefore don’t use the SeeAllData parameter.</p>",
        "image": ""
      },
      {
        "text": "<p>The test method contains the Test.startTest() and Test.stopTest() method pair, which delimits a block of code that gets a fresh set of governor limits. In this test, test-data setup uses two DML statements before the test is performed. To test that Apex code runs within governor limits, isolate data setup’s limit usage from your test’s. To isolate the data setup process’s limit usage, enclose the test call within the Test.startTest() and Test.stopTest() block. Also use this test block when testing asynchronous Apex. For more information, see Using Limits, startTest, and stopTest.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1100,
    "date": "2020/12/13",
    "title": "Visualforce",
    "itemList": [
      {
        "text": "<p>Visualforce is a web development framework that enables developers to build sophisticated, custom user interfaces for mobile and desktop apps that can be hosted on the Lightning Platform. You can use Visualforce to build apps that align with the styling of Lightning Experience, as well as your own completely custom interface. Visualforce enables developers to extend Salesforce’s built-in features, replace them with new functionality, and build completely new apps. Use powerful built-in standard controller features, or write your own custom business logic in Apex. You can build functionality for your own organization, or create apps for sale in the AppExchange.</p>",
        "image": ""
      },
      {
        "text": "<p>Visualforce app development is familiar to anyone who has built web apps. Developers create Visualforce pages by composing components, HTML, and optional styling elements. Visualforce can integrate with any standard web technology or JavaScript framework to allow for a more animated and rich user interface. Each page is accessible by a unique URL. When someone accesses a page the server performs any data processing required by the page, renders the page into HTML, and returns the results to the browser for display. Visualforce request processing overview.</p>",
        "image": ""
      },
      {
        "text": "<p>To see your page in the context of Lightning Experience, return to your main Lightning Experience browser window. Open your browser’s JavaScript console and enter the following code. Don’t forget to replace pageName with your page’s name:<br><code>$A.get('e.force:navigateToURL').setParams({'url':'/apex/HelloWorld'}).fire();</code></p>",
        "image": ""
      },
      {
        "text": "<p><b>Static Resources</b><br>Static resources allow you to upload content that you can reference in a Visualforce page. Resources can be archives (such as .zip and .jar files), images, stylesheets, JavaScript, and other files.Static resources are managed and distributed by Lightning Platform, which acts as a content distribution network (CDN) for the files. Caching and distribution are handled automatically.</p><p>Static resources are referenced using the $Resource global variable, which can be used directly by Visualforce, or used as a parameter to functions such as URLFOR().</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1200,
    "date": "2020/12/15",
    "title": "Field History Tracking",
    "itemList": [
      {
        "text": "<p>You can select certain fields to track and display the field history in the History related list of an object. Field history data is retained for up to 18 months through your org, and up to 24 months via the API. Field history tracking data doesn’t count against your Salesforce org’s data storage limits.</p>",
        "image": ""
      },
      {
        "text": "<p>Modifying any of these fields adds an entry to the History related list. All entries include the date, time, nature of the change, and who made the change. Not all field types are available for historical trend reporting. Certain changes, such as case escalations, are always tracked.</p>",
        "image": ""
      },
      {
        "text": "<p>Modifying any of these fields adds an entry to the History related list. All entries include the date, time, nature of the change, and who made the change. Not all field types are available for historical trend reporting. Certain changes, such as case escalations, are always tracked.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1300,
    "date": "2020/12/13",
    "title": "Lightning Component Framework",
    "itemList": [
      {
        "text": "<p>The Lightning Component framework is a UI framework for developing web apps for mobile and desktop devices. It’s a modern framework for building single-page applications with dynamic, responsive user interfaces for Lightning Platform apps. It uses JavaScript on the client side and Apex on the server side.</p><p>You can use the Developer Console to create Aura components. Using the Developer Console, you can create a component bundle. A component bundle acts like a folder in that it contains components and all other related resources, such as style sheets, controllers, and design.</p>",
        "image": "../assets/image/server/salesforce/lightningPlatform.PNG",
        "imageClass": "mx-auto d-block"
      },
      {
        "text": "<p>“How does the Lightning Component framework compare to MyFavoriteFramework?” where that favorite framework is another modern JavaScript web app framework such as AngularJS, React, or Ember. These frameworks are a great way to build Lightning Platform apps!</p><p>We recommend using them with Visualforce, using what we call a container page, and packaging your chosen framework and app code into static resources. Using an empty container page has Visualforce get out of your way, and lets you use the full capabilities of your chosen framework.</p>",
        "image": ""
      },
      {
        "text": "<p>Visualforce app development is familiar to anyone who has built web apps. Developers create Visualforce pages by composing components, HTML, and optional styling elements. Visualforce can integrate with any standard web technology or JavaScript framework to allow for a more animated and rich user interface. Each page is accessible by a unique URL. When someone accesses a page the server performs any data processing required by the page, renders the page into HTML, and returns the results to the browser for display. Visualforce request processing overview.</p>",
        "image": ""
      },
      {
        "text": "<p>Lightning components are supposed to be self-contained. They are stand-alone elements that encapsulate all of their essential functionality. A component is not allowed to reach into another component, even a child component, and alter its internals.</p><p>There are two principal ways to interact with or affect another component. The first way is one we’ve seen and done quite a bit of already: setting attributes on the component’s tag. A component’s public attributes constitute one part of its API.</p><p>The second way to interact with a component is through events. Like attributes, components declare the events they send out, and the events they can handle. Like attributes, these public events constitute a part of the component’s public API. We’ve actually used and handled events already, but the events have been hiding behind some convenience features. In this unit, we’ll drag events out into the light, and create a few of our own.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1400,
    "date": "2020/12/16",
    "title": "Lightning Platform APIs",
    "itemList": [
      {
        "text": "<p>In the sea of Salesforce APIs, there’s a key archipelago of commonly used APIs that we focus on in this module. They are REST API, SOAP API, Bulk API, and Streaming API. Together they make up the Salesforce data APIs. Their purpose is to let you manipulate your Salesforce data, whereas other APIs let you do things like customize page layouts or build custom development tools. You can use other Salesforce APIs to manipulate subsets of your Salesforce data, too. For example, Analytics REST API focuses on Analytics. But these four APIs apply broadly across the spectrum of core Salesforce data.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Rest API</b></p>",
        "image": ""
      },
      {
        "text": "<p><b>SOAP API</b></p>",
        "image": ""
      },
      {
        "text": "<p><b>Bulk API</b><br>Bulk API is a specialized RESTful API for loading and querying lots of data at once. By lots, we mean 50,000 records or more. Bulk API is asynchronous, meaning that you can submit a request and come back later for the results. This approach is the preferred one when dealing with large amounts of data. There are two versions of Bulk API (1.0 and 2.0). Both versions handle large amounts of data, but we use Bulk API 2.0 in this module because it’s a bit easier to use.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Streaming API</b><br>Streaming API is a specialized API for setting up notifications that trigger when changes are made to your data. It uses a publish-subscribe, or pub/sub, model in which users can subscribe to channels that broadcast certain types of data changes.</p><p>The pub/sub model reduces the number of API requests by eliminating the need for polling. Streaming API is great for writing apps that would otherwise need to frequently poll for changes.</p>",
        "image": ""
      },
      {
        "text": "<p>Streaming API is your radar. It lets you define events and push notifications to your client app when the events occur. You don’t have to keep an active lookout for data changes—you don’t have to constantly poll Salesforce and make unnecessary API requests.</p><p>Tracking data changes in Salesforce is especially useful when you have business data stored in a system external to Salesforce. You can use Streaming API to keep your external source in sync with your Salesforce data with PushTopic events and Change Data Capture events. Also, Streaming API lets you process business logic in an external system in response to data changes in Salesforce. For example, you can use Streaming API to notify a fulfillment center whenever an opportunity is updated.</p><p>In addition to data changes, you can use Streaming API to broadcast custom notifications with platform events and generic streaming. For example, an app can generate platform event notifications for orders that an order fulfillment service processes. Or an app can listen to generic events and display a message whenever a system maintenance window is about to start or when a new offer is available to your users.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1500,
    "date": "2020/12/19",
    "title": "User Interface API",
    "itemList": [
      {
        "text": "<p>The foundation of the Lightning stack is User Interface API, which gives you payloads of Salesforce data and metadata that are structured for building UI. Use your favorite web framework or language to build any custom web or native mobile app that you can imagine. React, Vue, Angular, iOS, Android...if you can make an HTTP request, you can use User Interface API.</p>",
        "image": ""
      },
      {
        "text": "<p>Salesforce has many APIs and it can be difficult to know which is the best tool for the job. If you’re building a custom web or mobile app and need a user interface that lets users view, create, edit, and delete Salesforce records—a user interface that looks and behaves like Salesforce—UI API is the way to go.</p>",
        "image": ""
      },
      {
        "text": "<p>If you’re building a user interface to let users edit dependent picklists and lookups, User Interface API is definitely the way to go. User Interface API has a resource that makes it a whole lot easier.</p>",
        "image": ""
      },
      {
        "text": "<p>Don’t use User Interface API for system integration. Or to create an automated integration for uploading or extracting data. Or to upload or extract data in bulk. Use the Enterprise API or the Bulk API for those tasks.</p>",
        "image": ""
      },
      {
        "text": "<p>If you’re building Lightning components, don’t use UI API directly, use Lightning Data Service (LDS).</p><p>LDS is built on User Interface API, but it also caches responses and updates all records that are affected by the data changes. When you’re working with LDS, you don’t have to worry about making REST calls and caching results, because LDS does it for you. And when data changes, LDS updates all the relevant components. Not only does LDS eliminate inconsistent data between components, it also lets users work offline and syncs the data when they go back online. LDS is cool.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1550,
    "date": "2020/12/31",
    "title": "Understanding Metadata API",
    "itemList": [
      {
        "text": "<p>Metadata API contains a set of objects that manage setup and customization information (metadata) for your organizations, and the SOAP calls that manipulate those objects. With Metadata API you can:<ul><li>Work with setup configuration as XML metadata files</li><li>Migrate configuration changes between organizations</li><li>Create your own tools for managing organization and application metadata</li></ul></p><p>Although you can write your own client applications for using Metadata API SOAP calls, Salesforce provides the Ant Migration Tool to retrieve and deploy Apex and metadata.</p>",
        "image": ""
      },
      {
        "text": "<p><b>Understanding Package and Directory Structure</b></p><p>Metadata API functions in a package-centric manner. Components can be in one or more packages, or in no package. Packages can be local (created in your Salesforce org) or installed from Salesforce AppExchange. Whenever the Ant Migration Tool retrieves a set of components, that set is limited to what’s in a single package or what’s in no package at all. There are three kinds of packages.<ul><li>Unpackaged—Components that live natively in your organization, such as standard objects, go in the unpackaged package.</li><li>Unmanaged package—Unmanaged packages are typically used to distribute open-source projects or application templates to provide developers with the basic building blocks for an application. Once the components are installed from an unmanaged package, the components can be edited in the organization they are installed in. The developer who created and uploaded the unmanaged package has no control over the installed components, and can't change or upgrade them. Unmanaged packages should not be used to migrate components from a sandbox to production organization. Instead, use Change Sets.</li><li>Managed package—A collection of application components that is posted as a unit on the AppExchange and associated with a namespace and possibly a License Management Organization. To support upgrades, a package must be managed. An organization can create a single managed package that can be downloaded and installed by many different organizations. Managed packages differ from unmanaged packages by having some locked components, allowing the managed package to be upgraded later. Unmanaged packages do not include locked components and cannot be upgraded. In addition, managed packages obfuscate certain components (like Apex) on subscribing organizations to protect the intellectual property of the developer.</li></ul></p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1600,
    "date": "2020/12/19",
    "title": "Apex Web Services",
    "itemList": [
      {
        "text": "<b>Expose a Class as a REST Service</b><p>Making your Apex class available as a REST web service is straightforward. Define your class as global, and define methods as global static. Add annotations to the class and methods. For example, this sample Apex REST class uses one method. The getRecord method is a custom REST API call. It’s annotated with @HttpGet and is invoked for a GET request.</p>",
        "image": ""
      },
      {
        "text": "<b>Expose a Class as a SOAP Service</b><p>Making your Apex class available as a SOAP web service is as easy as with REST. Define your class as global. Add the webservice keyword and the static definition modifier to each method you want to expose. The webservice keyword provides global access to the method it is added to.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1700,
    "date": "2020/12/17",
    "title": "Salesforce Tips",
    "itemList": [
      {
        "text": "<p>Salesforce’s Winter ’19 release introduced the amazing <b>‘Where is this used?’ feature</b>. This feature makes it possible for administrators to access Metadata without enabling access to Data. Users can now easily create, edit, and delete Metadata without touching the Data. Users can check references to a custom field, such as Layout or Apex Trigger, by clicking on the ‘Where is this used?’ button.</p>",
        "image": ""
      },
      {
        "text": "------<p>To get all tracked fields on Account you can use:</p><p><code>SELECT Label, QualifiedApiName FROM FieldDefinition WHERE EntityDefinition.QualifiedApiName = 'Account' AND IsFieldHistoryTracked = true</code></p>",
        "image": ""
      },
      {
        "text": "------<p>Use Workbench to Call User Interface API:</p><p><code>/services/data/v48.0/ui-api/object-info</code></p>",
        "image": ""
      },
      {
        "text": "------<p>Use Workbench to fetch a Record:</p><p><code>/services/data/v48.0/ui-api/record-ui/{recordIds}</code></p>",
        "image": ""
      },
      {
        "text": "------<p>Use Workbench to fetch sobjects:</p><p><code>/services/data/v49.0/sobjects/</code></p>",
        "image": ""
      },
      {
        "text": "------<p>Each batch Apex invocation creates an AsyncApexJob record so that you can track the job’s progress. You can view the progress via SOQL or manage your job in the Apex Job Queue:</p><p><code>AsyncApexJob job = [SELECT Id, Status, JobItemsProcessed, TotalJobItems, NumberOfErrors FROM AsyncApexJob WHERE ID = :batchId ]</code></p>",
        "image": ""
      },
      {
        "text": "------<p>$A is a framework global variable that provides a number of important functions and services. $A.enqueueAction(action) adds the server call to the Aura component framework request queue.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 1800,
    "date": "2020/12/20",
    "title": "Asynchronous Apex",
    "itemList": [
      {
        "text": "<p>In a nutshell, asynchronous Apex is used to run processes in a separate thread, at a later time. An asynchronous process is a process or function that executes a task 'in the background' without the user having to wait for the task to finish.</p>",
        "image": ""
      },
      {
        "text": "<p>Asynchronous Apex comes in a number of different flavors. We’ll get into more detail for each one shortly, but here’s a high level overview.</p>",
        "image": "../assets/image/server/salesforce/asynchronousApex.PNG",
        "imageClass": "mx-auto d-block"
      },
      {
        "text": "<p>Batch Apex is typically stateless. Each execution of a batch Apex job is considered a discrete transaction. For example, a batch Apex job that contains 1,000 records and uses the default batch size is considered five transactions of 200 records each.</p><p>If you specify Database.Stateful in the class definition, you can maintain state across all transactions. When using Database.Stateful, only instance member variables retain their values between transactions. Maintaining state is useful for counting or summarizing records as they’re processed. In our next example, we’ll be updating contact records in our batch job and want to keep track of the total records affected so we can include it in the notification email.</p>",
        "image": ""
      },
      {
        "text": "<b>Queueable Apex</b><p>Queueable Apex is essentially a superset of future methods with some extra #awesomesauce. We took the simplicity of future methods and the power of Batch Apex and mixed them together to form Queueable Apex! It gives you a class structure that the platform serializes for you, a simplified interface without start and finish methods and even allows you to utilize more than just primitive arguments! It is called by a simple System.enqueueJob() method, which returns a job ID that you can monitor. It beats sliced bread hands down!</p>",
        "image": ""
      },
      {
        "text": "<p>Queueable Apex allows you to submit jobs for asynchronous processing similar to future methods with the following additional benefits:<ul><li>Non-primitive types: Your Queueable class can contain member variables of non-primitive data types, such as sObjects or custom Apex types. Those objects can be accessed when the job executes.</li><li>Monitoring: When you submit your job by invoking the System.enqueueJob method, the method returns the ID of the AsyncApexJob record. You can use this ID to identify your job and monitor its progress, either through the Salesforce user interface in the Apex Jobs page, or programmatically by querying your record from AsyncApexJob.</li><li>Chaining jobs: You can chain one job to another job by starting a second job from a running job. Chaining jobs is useful if you need to do some sequential processing.</li></ul></p>",
        "image": ""
      },
      {
        "text": "<b>Scheduled Apex</b><p>The Apex Scheduler lets you delay execution so that you can run Apex classes at a specified time. This is ideal for daily or weekly maintenance tasks using Batch Apex. To take advantage of the scheduler, write an Apex class that implements the Schedulable interface, and then schedule it for execution on a specific schedule.</p>",
        "image": ""
      },
      {
        "text": "<p>The class implements the Schedulable interface and must implement the only method that this interface contains, which is the execute method.<br>The parameter of this method is a SchedulableContext object. After a class has been scheduled, a CronTrigger object is created that represents the scheduled job. It provides a getTriggerId method that returns the ID of a CronTrigger API object.</p>",
        "image": ""
      }
    ]
  },
  {
    "id": 3000,
    "date": "2020/12/01",
    "title": "Salesforce Page Layout",
    "itemList": [
      {
        "text": "<p>There are two ways to customize a page in Lightning Experience. You can customize a page’s layout, or customize its contents. These are done with separate tools.</p><p>Lightning pages are a collection of Lightning components arranged in regions on the page. You can customize the structure of the page and the position of its components with the Lightning App Builder (learn more in the Lightning App Builder module right here on Trailhead).</p><p>You can customize a page’s contents, such as the fields and buttons that appear on the page, by using a different tool called the <b>page layout editor</b>. The page layout editor, also known as page layouts, helps you manage the content of pages in both our Classic UI and in Lightning Experience. The page layout editor is what we’ll be working with in this unit.</p>",
        "image": ""
      }
    ]
  }
]